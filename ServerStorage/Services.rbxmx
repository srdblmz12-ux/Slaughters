<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXFBA4180BBBB84A8DBD45A70A55881B69">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">Services</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBX0B7A5C8977A14EC9B6188A5B65055C52">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Services = ServerStorage:WaitForChild("Services")
local Modules = ServerStorage:WaitForChild("Modules")
local GameModesFolder = Modules:WaitForChild("GameModes")

local Promise = require(Packages:WaitForChild("Promise"))
local Signal = require(Packages:WaitForChild("Signal"))
local Charm = require(Packages:WaitForChild("Charm"))
local Net = require(Packages:WaitForChild("Net"))

-- Service Dependencies
local PlayerService = require(Services:WaitForChild("PlayerService"))
local MapService = require(Services:WaitForChild("MapService"))
local SpawnerService = require(Services:WaitForChild("SpawnerService"))

-- Constants
local CONFIG = {
	VOTING_TIME = 15,
	WARMUP_TIME = 10,
	GAME_TIME = 180,
	INTERMISSION = 5,
	MIN_PLAYERS = 2
}

-- Module Definition
local GameService = {
	Name = script.Name,
	Client = {},

	-- Global State Atoms
	Gamemode = Charm.atom("Waiting"),
	TimeLeft = Charm.atom(0),
	GameStatus = Charm.atom("Waiting"), -- "Voting", "Loading", "Warmup", "InGame"

	-- Admin Override State
	NextMapOverride = Charm.atom(nil),

	-- Voting State
	CurrentOptions = Charm.atom({}), 
	Votes = Charm.atom({}),          

	-- Internal Game State
	RunningPlayers = {}, 
	_connections = {}, 
	_gameLoopTask = nil,
	_activeModeModule = nil,

	-- EKSİK OLAN SİNYALLER EKLENDİ BURAYA:
	Signals = {
		GameEnded = Signal.new(),
		WarmupStarted = Signal.new(), -- SurvivorService bunu dinleyecek
		GameStarted = Signal.new(),   -- SurvivorService bunu dinleyecek
	},

	Network = {
		-- State Sync
		StateUpdate = Net:RemoteEvent("StateUpdate"),

		-- Phase Events
		VoteOptions = Net:RemoteEvent("VoteOptions"), 
		WarmupStarted = Net:RemoteEvent("WarmupStarted"),
		GameStarted = Net:RemoteEvent("GameStarted"),
		GameEnded = Net:RemoteEvent("GameEnded"),

		-- Actions
		CastVote = Net:RemoteEvent("CastVote"),
		LoadLighting = Net:RemoteEvent("LoadLighting"),
	}
}

-- =============================================================================
--  ADMIN & HELPER FUNCTIONS
-- =============================================================================

function GameService:SetNextMap(mapName)
	local module = MapService:FindMapModule(mapName)
	if module then
		self.NextMapOverride(module)
		print("[ADMIN] Sıradaki harita ayarlandı: " .. module.Name)
		return true
	end
	warn("[ADMIN] Harita bulunamadı: " .. mapName)
	return false
end

function GameService:CastVote(player, optionIndex)
	if self.GameStatus() ~= "Voting" then return end
	if type(optionIndex) ~= "number" then return end

	local options = self.CurrentOptions()
	if optionIndex < 1 or optionIndex > #options then return end

	self.Votes(function(current)
		local new = table.clone(current)
		new[player.UserId] = optionIndex
		return new
	end)
end

-- =============================================================================
--  GAME PHASES
-- =============================================================================

function GameService:RunVotingPhase()
	self.GameStatus("Voting")
	self.TimeLeft(CONFIG.VOTING_TIME)

	local options = MapService:GetVoteOptions(3)
	self.CurrentOptions(options)
	self.Votes({})

	self.Network.VoteOptions:FireAllClients(options)

	for i = CONFIG.VOTING_TIME, 1, -1 do
		self.TimeLeft(i)
		task.wait(1)
		if #Players:GetPlayers() < CONFIG.MIN_PLAYERS then return nil end
	end

	local counts = {0, 0, 0}
	for _, idx in pairs(self.Votes()) do
		if counts[idx] then counts[idx] += 1 end
	end

	local winnerIndex = math.random(1, #options)
	local maxVotes = -1

	for i, count in ipairs(counts) do
		if i <= #options then
			if count > maxVotes then
				maxVotes = count
				winnerIndex = i
			elseif count == maxVotes and math.random() > 0.5 then
				winnerIndex = i
			end
		end
	end

	return options[winnerIndex]
end

function GameService:StartGame()
	local activePlayers = Players:GetPlayers()
	if #activePlayers < CONFIG.MIN_PLAYERS then 
		return Promise.reject("Yetersiz Oyuncu") 
	end

	-- [AŞAMA 1] HARİTA BELİRLEME
	local mapModule = self.NextMapOverride()

	if mapModule then
		print("Admin Override Aktif. Oylama atlanıyor.")
		self.NextMapOverride(nil) 
		self.GameStatus("Loading")
		task.wait(2)
	else
		mapModule = self:RunVotingPhase()
	end

	if not mapModule then return Promise.reject("Harita seçilemedi") end

	self.GameStatus("Loading")

	-- [AŞAMA 2] VERİ YÜKLEME
	local promises = {}
	for _, p in ipairs(activePlayers) do
		table.insert(promises, PlayerService:GetProfile(p))
	end

	return Promise.all(promises):andThen(function()

		-- [AŞAMA 3] HARİTA & LIGHTING YÜKLEME
		local mapData = MapService:LoadMap(mapModule)
		if not mapData then error("Harita yüklenemedi!") end

		if mapData.Lighting then
			self.Network.LoadLighting:FireAllClients(mapData.Lighting)
		end

		-- [AŞAMA 4] OYUN MODU & ROLLER
		self:_setupGameMode(activePlayers)

		-- [AŞAMA 5] WARMUP (SAKLANMA)
		self.GameStatus("Warmup")
		self.TimeLeft(CONFIG.WARMUP_TIME)

		-- Network Event (Client için)
		self.Network.WarmupStarted:FireAllClients(self.Gamemode(), self._activeModeModule:GetRoles(), CONFIG.WARMUP_TIME)

		-- Internal Signal (SurvivorService için - BURASI EKLENDİ)
		self.Signals.WarmupStarted:Fire() 

		-- Survivor Spawn
		SpawnerService:SpawnSurvivors(self.RunningPlayers, mapData.Spawns)
		self:_setupSurvivorMonitoring()

		-- Warmup Loop
		for i = CONFIG.WARMUP_TIME, 1, -1 do
			self.TimeLeft(i)
			task.wait(1)
			if #Players:GetPlayers() < CONFIG.MIN_PLAYERS then self:EndGame() return end
		end

		-- [AŞAMA 6] OYUN BAŞLANGICI (KATİL GELİYOR)
		self.GameStatus("InGame")

		SpawnerService:SpawnKillers(self.RunningPlayers, mapData.Spawns)

		-- Network Event
		self.Network.GameStarted:FireAllClients()

		-- Internal Signal (SurvivorService için - BURASI EKLENDİ)
		self.Signals.GameStarted:Fire()

		self:_startTimeLoop()

	end):catch(function(err)
		warn("Game Start Error:", err)
		self:EndGame()
	end)
end

-- =============================================================================
--  INTERNAL HELPERS
-- =============================================================================

function GameService:_setupGameMode(players)
	local modes = GameModesFolder:GetChildren()
	local selectedScript = modes[math.random(1, #modes)]
	local modeModule = require(selectedScript)

	if modeModule.MinPlayers and #players < modeModule.MinPlayers then
		modeModule = require(GameModesFolder.Classic)
		selectedScript = GameModesFolder.Classic
	end

	self._activeModeModule = modeModule
	self.Gamemode(selectedScript.Name)

	local roles = modeModule:Start(self, players)
	self.RunningPlayers = {}

	for player, role in pairs(roles) do
		self.RunningPlayers[player] = Charm.atom(role)

		if role == "Killer" then
			PlayerService:ResetChance(player)
		elseif role == "Survivor" then
			PlayerService:AddChance(player, 1)
		end
	end
end

function GameService:_setupSurvivorMonitoring()
	for player, roleAtom in pairs(self.RunningPlayers) do
		if roleAtom() == "Survivor" then
			local function onDeath(char)
				local hum = char:WaitForChild("Humanoid", 10)
				if hum then
					local conn = hum.Died:Connect(function()
						if self.GameStatus() == "InGame" and self._activeModeModule then
							self._activeModeModule:OnPlayerDied(self, player)
						end
					end)
					table.insert(self._connections, conn)
				end
			end

			if player.Character then onDeath(player.Character) end
			local conn = player.CharacterAdded:Connect(onDeath)
			table.insert(self._connections, conn)
		end
	end
end

function GameService:_startTimeLoop()
	if self._gameLoopTask then task.cancel(self._gameLoopTask) end

	self.TimeLeft(CONFIG.GAME_TIME)

	self._gameLoopTask = task.spawn(function()
		while self.TimeLeft() > 0 do
			task.wait(1)
			self.TimeLeft(self.TimeLeft() - 1)

			if self._activeModeModule and self._activeModeModule.CheckWinCondition then
				if self._activeModeModule:CheckWinCondition(self) then break end
			end
		end
		self:EndGame()
	end)
end

function GameService:EndGame(Executable)
	if self._gameLoopTask then task.cancel(self._gameLoopTask) self._gameLoopTask = nil end
	for _, conn in ipairs(self._connections) do conn:Disconnect() end
	self._connections = {}

	self.GameStatus("Waiting")
	self.Gamemode("Waiting")
	self.TimeLeft(0)
	self._activeModeModule = nil
	self.RunningPlayers = {}

	self.Votes({})
	self.CurrentOptions({})
	self.NextMapOverride(nil)

	-- Network Duyuru
	self.Network.GameEnded:FireAllClients()

	-- Internal Signal (SurvivorService için - BURASI ZATEN VARDI)
	self.Signals.GameEnded:Fire()

	-- Fiziksel Reset
	MapService:Cleanup()
	SpawnerService:DespawnAll()

	if Executable then task.spawn(Executable) end
end

-- =============================================================================
--  INITIALIZATION
-- =============================================================================

function GameService:OnStart()
	local function sync(name, atom)
		Charm.effect(function()
			self.Network.StateUpdate:FireAllClients(name, atom())
		end)
	end

	sync("Gamemode", self.Gamemode)
	sync("GameStatus", self.GameStatus)
	sync("TimeLeft", self.TimeLeft)

	self.Network.CastVote.OnServerEvent:Connect(function(plr, idx)
		self:CastVote(plr, idx)
	end)

	task.spawn(function()
		while true do
			while #Players:GetPlayers() < CONFIG.MIN_PLAYERS do
				task.wait(5)
			end

			task.wait(CONFIG.INTERMISSION)

			local promise = self:StartGame()
			if promise and promise:getStatus() ~= Promise.Status.Rejected then
				self.Signals.GameEnded:Wait()
			end

			print("Oyun bitti, Lobiye dönülüyor...")
			task.wait(3)
		end
	end)
end

return GameService]]></ProtectedString>
				<string name="ScriptGuid">{16AB58D6-0947-48A1-AF2C-9237A352B3C2}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">GameService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX20121168CC144CFA9D6EA7954BB30396">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Modules = ServerStorage:WaitForChild("Modules")

local ProfileStore = require(Modules:WaitForChild("ProfileStore"))

local Promise = require(Packages:WaitForChild("Promise"))
local Signal = require(Packages:WaitForChild("Signal"))
local Charm = require(Packages:WaitForChild("Charm"))

local Store = ProfileStore.New(RunService:IsStudio() and "Test" or "Live0", {
	CurrencyData = {
		Spent = 0,
		Total = 0,
		Value = 0,
		Name = "Token"
	},
	LevelData = {
		TargetXP = 100,
		ValueXP = 0,
		Level = 1,
		Name = "Level"
	},
	MurdererSkill = "Default"
})

-- Module
local PlayerService = {
	Name = script.Name,
	Client = {},
	
	LoadedPlayers = {}, 
	Signals = {
		PlayerAdded = Signal.new(),
		PlayerRemoved = Signal.new(),
	}
}

--// Client Functions

function PlayerService.Client:GetChance(player)
	return PlayerService:GetChance(player)
end

function PlayerService.Client:GetData(player)
	local success, profile = PlayerService:GetProfile(player):await()
	if success and profile then
		return profile.Data
	else
		warn("Data alınamadı: " .. player.Name)
		return nil
	end
end

--// Server Functions

-- Promise döndüren Async GetProfile
function PlayerService:GetProfile(player)
	return Promise.new(function(resolve, reject)
		local container = self.LoadedPlayers[player]

		if container and container.Profile then
			resolve(container.Profile)
		else
			-- Profil henüz yüklenmemişse veya oyuncu yoksa reject
			reject("Profile not loaded or player not found: " .. player.Name)
		end
	end)
end

function PlayerService:GetChance(player)
	local container = self.LoadedPlayers[player]
	if container and container.Atom then
		return container.Atom()
	end
	return 0 -- Yüklenmediyse 0 döndür
end

function PlayerService:ResetChance(player)
	local container = self.LoadedPlayers[player]
	if container and container.Atom then
		container.Atom(0) -- Şansı sıfırlar
	end
end

function PlayerService:AddChance(player, amount)
	local container = self.LoadedPlayers[player]
	if container and container.Atom then
		amount = amount or 1
		-- Atom'u güncelle (Sadece RAM'de, dataya yazmaz)
		container.Atom(function(current)
			return current + amount
		end)
	end
end

function PlayerService:PlayerLoaded(player)
	local profile = Store:StartSessionAsync("Player_" .. player.UserId)
	if profile ~= nil then
		if player:IsDescendantOf(Players) then
			local chanceAtom = Charm.atom(0)
			self.LoadedPlayers[player] = {
				Profile = profile,
				Atom = chanceAtom
			}
			
			self.Signals.PlayerAdded:Fire(player, profile)
			print(player.Name .. " yüklendi. (Data Template Clean)")
		else
			profile:Release()
		end
	else
		player:Kick("Profile load failed. Please rejoin.")
	end
end

function PlayerService:RemovePlayer(player)
	local container = self.LoadedPlayers[player]
	if container then
		if container.Profile then
			container.Profile:Release()
		end
		self.LoadedPlayers[player] = nil
		self.Signals.PlayerRemoved:Fire(player)
	end
end

function PlayerService:OnStart()
	Players.PlayerAdded:Connect(function(player)
		task.spawn(function()
			self:PlayerLoaded(player)
		end)
	end)
	
	Players.PlayerRemoving:Connect(function(player)
		self:RemovePlayer(player)
	end)
	
	for _, player in ipairs(Players:GetPlayers()) do
		task.spawn(function()
			self:PlayerLoaded(player)
		end)
	end
end

return PlayerService]]></ProtectedString>
				<string name="ScriptGuid">{67893CAD-3B35-493F-AB9E-EA85AB722B92}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">PlayerService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXF4EA00071DE04059A2B4FDA3F15BA284">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Services = ServerStorage:WaitForChild("Services")
local Modules = ServerStorage:WaitForChild("Modules")
local SkillsFolder = Modules:WaitForChild("MurdererSkills")

local Charm = require(Packages:WaitForChild("Charm"))
local Net = require(Packages:WaitForChild("Net"))
local Promise = require(Packages:WaitForChild("Promise"))

local GameService = require(Services:WaitForChild("GameService"))
local PlayerService = require(Services:WaitForChild("PlayerService"))

-- Module
local MurdererService = {
	Name = script.Name,
	Client = {},

	-- Cooldown Takibi (Skill bazlı atom yapısı)
	Cooldowns = {}, 

	Network = {
		ActivateSkill = Net:RemoteEvent("ActivateSkill"),
		CooldownUpdate = Net:RemoteEvent("CooldownUpdate"),
		SkillAssigned = Net:RemoteEvent("SkillAssigned"), -- Survivor ile ortak sinyal yapısı
	}
}

--// Helper
function MurdererService:IsMurderer(player)
	local roleAtom = GameService.RunningPlayers[player]
	return roleAtom and roleAtom() == "Killer"
end

--// Client: Yetenek Kullanma İsteği
function MurdererService:ActivateSkill(player, skillName, mousePosition)
	-- 1. Validasyonlar
	if not self:IsMurderer(player) then return end
	if GameService.Gamemode() == "Waiting" then return end
	if typeof(skillName) ~= "string" then return end
	if mousePosition and typeof(mousePosition) ~= "Vector3" then return end

	-- 2. Datadan Yeteneği Doğrula (Oyuncu gerçekten bu skille mi sahip?)
	PlayerService:GetProfile(player):andThen(function(profile)
		local equippedSkill = profile.Data.MurdererSkill or "Default"

		if skillName ~= equippedSkill then 
			warn(player.Name .. " sahip olmadığı yeteneği kullanmaya çalıştı.")
			return 
		end

		-- 3. Cooldown Kontrolü (Skill Bazlı)
		local currentTime = workspace:GetServerTimeNow()
		if not self.Cooldowns[player] then self.Cooldowns[player] = {} end

		local skillCooldownAtom = self.Cooldowns[player][skillName]
		if skillCooldownAtom and skillCooldownAtom() > currentTime then return end

		-- 4. Modülü Çalıştır
		local skillModuleScript = SkillsFolder:FindFirstChild(skillName) or SkillsFolder:FindFirstChild("Default")

		if skillModuleScript then
			local skillModule = require(skillModuleScript)
			skillModule:Activate(player, GameService, mousePosition)

			-- 5. Cooldown Ayarla
			local cooldownDuration = skillModule.Cooldown or 10
			local finishTime = currentTime + cooldownDuration

			if not self.Cooldowns[player][skillName] then
				self.Cooldowns[player][skillName] = Charm.atom(finishTime)
			else
				self.Cooldowns[player][skillName](finishTime)
			end

			-- Client'a hangi skillin cooldowna girdiğini bildir
			self.Network.CooldownUpdate:FireClient(player, skillName, finishTime)
		end
	end):catch(function(errorMessage)
		warn("Murderer skill hatası: " .. tostring(errorMessage))
	end)
end

--// Server: Oyun başında katilin skill bilgisini client'a gönder
function MurdererService:_initializeMurdererSkill()
	for player, roleAtom in pairs(GameService.RunningPlayers) do
		if roleAtom() == "Killer" then
			PlayerService:GetProfile(player):andThen(function(profile)
				local skillName = profile.Data.MurdererSkill or "Default"
				local skillModuleScript = SkillsFolder:FindFirstChild(skillName) or SkillsFolder:FindFirstChild("Default")

				if skillModuleScript then
					local skillModule = require(skillModuleScript)
					local cooldownTime = skillModule.Cooldown or 10

					-- Client'a skill ismini ve varsayılan cooldown süresini bildir
					self.Network.SkillAssigned:FireClient(player, skillName, cooldownTime)
				end
			end)
		end
	end
end

function MurdererService:OnStart()
	-- Event Listener (Client -> Server)
	self.Network.ActivateSkill.OnServerEvent:Connect(function(player, skillName, mousePosition)
		self:ActivateSkill(player, skillName, mousePosition)
	end)

	-- Oyun başladığında katilin skillini hazırla
	GameService.Signals.GameStarted:Connect(function()
		self:_initializeMurdererSkill()
	end)

	-- Oyun bittiğinde temizle
	GameService.Signals.GameEnded:Connect(function()
		self.Cooldowns = {}
	end)
end

return MurdererService]]></ProtectedString>
				<string name="ScriptGuid">{E9339E40-B832-4819-B828-65E9982FDB1E}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">MurdererService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXE58554A14572439CB5E9C1BEC163675A">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Services = ServerStorage:WaitForChild("Services")
local Modules = ServerStorage:WaitForChild("Modules")
local SkillsFolder = Modules:WaitForChild("SurvivorSkills")

local Charm = require(Packages:WaitForChild("Charm"))
local Net = require(Packages:WaitForChild("Net"))

local GameService = require(Services:WaitForChild("GameService"))

local SurvivorService = {
	Name = script.Name,
	Client = {},

	-- State
	IsSelectionOpen = false,
	AreSkillsActive = false, 

	SelectedSkills = {}, -- Artık burası { [Player] = {"SkillA", "SkillB"} } yapısında olacak
	Cooldowns = {},      -- Artık burası { [Player] = { ["SkillA"] = atom, ["SkillB"] = atom } } yapısında olacak

	Network = {
		SelectSkill = Net:RemoteEvent("SelectSkill"), 
		SkillAssigned = Net:RemoteEvent("SkillAssigned"), 
		ActivateSkill = Net:RemoteEvent("ActivateSkill"), 
		CooldownUpdate = Net:RemoteEvent("CooldownUpdate"),
	}
}

--// Helper: Oyuncu Survivor mı?
function SurvivorService:IsSurvivor(player)
	local roleAtom = GameService.RunningPlayers[player]
	return roleAtom and roleAtom() == "Survivor"
end

--// Client: Skill Seçimi (Çoklu Seçim / Ekleme)
function SurvivorService:SelectSkill(player, skillName)
	if not self.IsSelectionOpen then return end
	if not self:IsSurvivor(player) then return end

	local skillModuleScript = SkillsFolder:FindFirstChild(skillName)
	if not skillModuleScript then return end

	-- Oyuncunun tablosunu oluştur (yoksa)
	if not self.SelectedSkills[player] then
		self.SelectedSkills[player] = {}
	end

	local playerSkills = self.SelectedSkills[player]

	-- Eğer oyuncu bu skilli zaten seçmediyse ekle
	if not table.find(playerSkills, skillName) then
		table.insert(playerSkills, skillName)

		-- Modülü require ederek içindeki Cooldown değerini alıyoruz
		local skillModule = require(skillModuleScript)
		local cooldownTime = skillModule.Cooldown or 20 -- Modülde yoksa varsayılan 20

		-- Client'a hem ismi hem de bekleme süresini gönderiyoruz
		self.Network.SkillAssigned:FireClient(player, skillName, cooldownTime)
	end
end

--// Server: Seçim Yapmayanlara Rastgele Ata
function SurvivorService:_finalizeSelections()
	self.IsSelectionOpen = false
	local availableSkills = SkillsFolder:GetChildren()
	if #availableSkills == 0 then return end 

	for player, roleAtom in pairs(GameService.RunningPlayers) do
		if roleAtom() == "Survivor" then
			if not self.SelectedSkills[player] or #self.SelectedSkills[player] == 0 then
				local randomSkillScript = availableSkills[math.random(1, #availableSkills)]
				local skillName = randomSkillScript.Name

				-- Cooldown bilgisini al
				local skillModule = require(randomSkillScript)
				local cooldownTime = skillModule.Cooldown or 20

				self.SelectedSkills[player] = { skillName }

				-- Client'a hem isim hem süre gönder
				self.Network.SkillAssigned:FireClient(player, skillName, cooldownTime)
			end
		end
	end
end

--// Client: Skill Kullanımı (Hangi Skill + Mouse Pozisyonu)
-- ARTIK BURASI "skillName" PARAMETRESİ ALIYOR
function SurvivorService:ActivateSkill(player, skillName, mousePosition)
	-- 1. Genel Kontroller
	if not self.AreSkillsActive then return end 
	if GameService.Gamemode() == "Waiting" then return end
	if not self:IsSurvivor(player) then return end

	-- 2. Parametre Kontrolü (Güvenlik)
	if typeof(skillName) ~= "string" then return end
	-- Mouse position kontrolü
	if mousePosition and typeof(mousePosition) ~= "Vector3" then return end

	-- 3. SAHİPLİK KONTROLÜ: Oyuncu bu skilli gerçekten seçmiş mi?
	local playerSkills = self.SelectedSkills[player]
	if not playerSkills or not table.find(playerSkills, skillName) then
		warn(player.Name .. " sahip olmadığı bir skilli kullanmaya çalıştı: " .. skillName)
		return 
	end

	-- 4. COOLDOWN KONTROLÜ (Skill Bazlı)
	local currentTime = workspace:GetServerTimeNow()

	-- Oyuncunun cooldown tablosunu hazırla
	if not self.Cooldowns[player] then self.Cooldowns[player] = {} end

	local skillCooldownAtom = self.Cooldowns[player][skillName]

	-- Eğer bu spesifik skillin cooldown süresi bitmediyse dur
	if skillCooldownAtom and skillCooldownAtom() > currentTime then return end

	-- 5. Modülü Çalıştır
	local skillModuleScript = SkillsFolder:FindFirstChild(skillName)
	if skillModuleScript then
		local skillModule = require(skillModuleScript)

		-- Modüle Player, GameService ve Mouse Pozisyonunu gönderiyoruz
		skillModule:Activate(player, GameService, mousePosition)

		-- 6. Cooldown Ayarla (Skill Bazlı)
		local cooldownDuration = skillModule.Cooldown or 20
		local finishTime = currentTime + cooldownDuration

		if not self.Cooldowns[player][skillName] then
			self.Cooldowns[player][skillName] = Charm.atom(finishTime)
		else
			self.Cooldowns[player][skillName](finishTime)
		end

		-- Client'a hangi skillin cooldowna girdiğini söylemeliyiz
		self.Network.CooldownUpdate:FireClient(player, skillName, finishTime)
	end
end

function SurvivorService:OnStart()
	-- Event Listeners
	self.Network.SelectSkill.OnServerEvent:Connect(function(player, skillName)
		self:SelectSkill(player, skillName)
	end)

	-- Client artık (SkillAdı, MousePozisyonu) gönderiyor
	self.Network.ActivateSkill.OnServerEvent:Connect(function(player, skillName, mousePosition)
		self:ActivateSkill(player, skillName, mousePosition)
	end)

	-- GameService Sinyalleri
	GameService.Signals.WarmupStarted:Connect(function()
		self.IsSelectionOpen = true
		self.AreSkillsActive = false
		self.SelectedSkills = {}
		self.Cooldowns = {}
		print("SurvivorService: Seçimler açıldı.")
	end)

	GameService.Signals.GameStarted:Connect(function()
		self:_finalizeSelections()
		self.AreSkillsActive = true
		print("SurvivorService: Skiller aktif edildi.")
	end)

	GameService.Signals.GameEnded:Connect(function()
		self.IsSelectionOpen = false
		self.AreSkillsActive = false
		self.SelectedSkills = {}
		self.Cooldowns = {}
	end)
end

return SurvivorService]]></ProtectedString>
				<string name="ScriptGuid">{49B839C4-3737-48BC-ADD4-EBB477D06EF6}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">SurvivorService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX629F36A895C84C769FA256CDCD11C204">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserService = game:GetService("UserService")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Charm = require(Packages:WaitForChild("Charm"))

-- Constants
local Shared = ReplicatedStorage:WaitForChild("Shared")
local MapsFolder = Shared:WaitForChild("Maps")

local MapService = {
	Name = script.Name,
	Client = {},

	CurrentMapInstance = nil,
	CurrentMapData = Charm.atom(nil), -- { Name, Authors, Module }
}

--// YARDIMCI: Harita Modülünü Bul (İsme göre)
function MapService:FindMapModule(mapName)
	for _, module in ipairs(MapsFolder:GetChildren()) do
		if module.Name:lower() == mapName:lower() then
			return module
		end
	end
	return nil
end

--// YARDIMCI: Oylama İçin Rastgele Seçenekler Getir
function MapService:GetVoteOptions(count)
	local allMaps = MapsFolder:GetChildren()
	local options = {}
	local usedIndices = {}

	-- Mevcut harita sayısı istenenden azsa hepsini döndür
	if #allMaps <= count then
		return allMaps
	end

	-- Rastgele ve eşsiz seçim yap
	while #options < count do
		local index = math.random(1, #allMaps)
		if not usedIndices[index] then
			usedIndices[index] = true
			table.insert(options, allMaps[index])
		end
	end

	return options
end

--// ÇEKİRDEK: Haritayı Yükle
function MapService:LoadMap(mapModule)
	self:Cleanup() -- Önceki haritayı temizle

	-- 1. Modülü Çalıştır (Require)
	local success, mapData = pcall(require, mapModule)
	if not success or not mapData then
		warn("Map Modülü yüklenemedi:", mapModule.Name, mapData)
		return nil
	end

	if not mapData.Map then
		warn("Map Data içinde 'Map' modeli yok:", mapModule.Name)
		return nil
	end

	-- 2. Haritayı Kopyala
	local newMap = mapData.Map:Clone()
	newMap.Name = "CurrentMap"
	newMap.Parent = Workspace
	self.CurrentMapInstance = newMap

	-- 3. Yazar İsimlerini Çek (UserId -> Username)
	local authorNames = {}
	if mapData.Authors and #mapData.Authors > 0 then
		task.spawn(function()
			local ok, infos = pcall(function()
				return UserService:GetUserInfosByUserIdsAsync(mapData.Authors)
			end)
			if ok and infos then
				local names = {}
				for _, info in ipairs(infos) do
					table.insert(names, info.DisplayName)
				end
				-- State'i sonradan güncelle (Async olduğu için)
				self.CurrentMapData(function(current)
					if current and current.Module == mapModule then
						local newData = table.clone(current)
						newData.Authors = names
						return newData
					end
					return current
				end)
			end
		end)
	end

	-- 4. State Güncelle (İlk başta yazarlar boş gelir, async dolar)
	self.CurrentMapData({
		Name = mapData.Name,
		Authors = {"Loading..."},
		Module = mapModule
	})

	print("MapService: '" .. mapData.Name .. "' başarıyla yüklendi.")

	-- 5. GameService'e Gerekli Verileri Döndür
	return {
		Spawns = self:GetSpawns(),
		Lighting = mapData.Lighting
	}
end

--// TEMİZLİK
function MapService:Cleanup()
	if self.CurrentMapInstance then
		self.CurrentMapInstance:Destroy()
		self.CurrentMapInstance = nil
	end
	self.CurrentMapData(nil)
end

--// SPAWN NOKTALARI
function MapService:GetSpawns()
	if not self.CurrentMapInstance then return {} end

	local spawnsFolder = self.CurrentMapInstance:FindFirstChild("Spawns")
	if spawnsFolder then return spawnsFolder:GetChildren() end

	local spawns = {}
	for _, obj in ipairs(self.CurrentMapInstance:GetDescendants()) do
		if obj:IsA("SpawnLocation") then table.insert(spawns, obj) end
	end
	return spawns
end

return MapService]]></ProtectedString>
				<string name="ScriptGuid">{AFFD8432-9DA3-4E0F-8912-0189DF6E09FE}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">MapService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX8F767795746249D094D071CB9E14180F">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local Players = game:GetService("Players")

local SpawnerService = {
	Name = script.Name,
	Client = {},
}

-- Survivorları Spawnla (Warmup Aşaması)
function SpawnerService:SpawnSurvivors(runningPlayers, spawnLocations)
	for player, roleAtom in pairs(runningPlayers) do
		if roleAtom() == "Survivor" then
			self:_spawnPlayer(player, spawnLocations)
		end
	end
end

-- Katilleri Spawnla (Oyun Başlangıcı)
function SpawnerService:SpawnKillers(runningPlayers, spawnLocations)
	for player, roleAtom in pairs(runningPlayers) do
		if roleAtom() == "Killer" then
			self:_spawnPlayer(player, spawnLocations)
		end
	end
end

-- Herkesi Lobiye Gönder (Reset)
function SpawnerService:DespawnAll()
	for _, player in ipairs(Players:GetPlayers()) do
		player.RespawnLocation = nil -- Default spawn'a döner
		player:LoadCharacterAsync()
	end
end

--// Internal Helper
function SpawnerService:_spawnPlayer(player, spawnLocations)
	if not player then return end

	-- Rastgele bir spawn seç
	if spawnLocations and #spawnLocations > 0 then
		local randomSpawn = spawnLocations[math.random(1, #spawnLocations)]
		player.RespawnLocation = randomSpawn
	end

	player:LoadCharacter()
end

return SpawnerService]]></ProtectedString>
				<string name="ScriptGuid">{A11CA0A5-5886-4499-B671-7FE8BA3DD414}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">SpawnerService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>