<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX6216494F3DB747CD8B5381F19AB66F57">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">Services</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXD50E9775C2E54C8A85F1D0B9FD55EA86">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Services = ServerStorage:WaitForChild("Services")
local Modules = ServerStorage:WaitForChild("Modules")
local GameModesFolder = Modules:WaitForChild("GameModes")

local Promise = require(Packages:WaitForChild("Promise"))
local Signal = require(Packages:WaitForChild("Signal"))
local Charm = require(Packages:WaitForChild("Charm"))
local Net = require(Packages:WaitForChild("Net"))

-- Service Dependencies
local PlayerService = require(Services:WaitForChild("PlayerService"))
local MapService = require(Services:WaitForChild("MapService"))
local SpawnerService = require(Services:WaitForChild("SpawnerService"))

-- Constants
local CONFIG = {
	VOTING_TIME = 15,
	WARMUP_TIME = 10,
	GAME_TIME = 180,
	INTERMISSION = 5,
	MIN_PLAYERS = 2
}

-- Module Definition
local GameService = {
	Name = script.Name,
	Client = {},

	-- Global State Atoms
	Gamemode = Charm.atom("Waiting"),
	TimeLeft = Charm.atom(0),
	GameStatus = Charm.atom("Waiting"), 

	-- Admin Override State
	NextMapOverride = Charm.atom(nil),

	-- Voting State
	CurrentOptions = Charm.atom({}), 
	Votes = Charm.atom({}),          

	-- Internal Game State
	RunningPlayers = {}, 
	_connections = {}, 
	_gameLoopTask = nil,
	_activeModeModule = nil,

	Signals = {
		GameEnded = Signal.new(),
		WarmupStarted = Signal.new(), 
		GameStarted = Signal.new(),   
	},

	Network = {
		StateUpdate = Net:RemoteEvent("StateUpdate"),
		VoteOptions = Net:RemoteEvent("VoteOptions"), -- Args: (Options, TimeLeft)
		VoteUpdate = Net:RemoteEvent("VoteUpdate"),   

		WarmupStarted = Net:RemoteEvent("WarmupStarted"),
		GameStarted = Net:RemoteEvent("GameStarted"),
		GameEnded = Net:RemoteEvent("GameEnded"),
		CastVote = Net:RemoteEvent("CastVote"),
		LoadLighting = Net:RemoteEvent("LoadLighting"),
	}
}

-- =============================================================================
--  HELPER FUNCTIONS
-- =============================================================================

function GameService:_calculateVoteCounts()
	local options = self.CurrentOptions()
	local votes = self.Votes()
	local counts = {}

	for _, data in ipairs(options) do
		counts[data.Id] = 0
	end

	for _, mapId in pairs(votes) do
		if counts[mapId] ~= nil then
			counts[mapId] = counts[mapId] + 1
		end
	end

	return counts
end

function GameService:SelectWeightedKiller(playerCandidates)
	local totalChance = 0
	local selectionPool = {}

	for _, player in ipairs(playerCandidates) do
		local chance = PlayerService:GetChance(player)
		if chance <= 0 then chance = 1 end

		totalChance = totalChance + chance
		table.insert(selectionPool, {Player = player, Weight = totalChance})
	end

	local randomNumber = math.random(1, totalChance)
	for _, poolEntry in ipairs(selectionPool) do
		if randomNumber <= poolEntry.Weight then
			return poolEntry.Player
		end
	end
	return playerCandidates[1]
end

function GameService:SetNextMap(mapName)
	local mapModule = MapService:FindMapModule(mapName)
	if mapModule then
		self.NextMapOverride(mapModule)
		print("[ADMIN] Sıradaki harita ayarlandı: " .. mapModule.Name)
		return true
	end
	warn("[ADMIN] Harita bulunamadı: " .. mapName)
	return false
end

function GameService:CastVote(player, mapId)
	if self.GameStatus() ~= "Voting" then return end
	if type(mapId) ~= "string" then return end

	local isValidOption = false
	for _, optionData in ipairs(self.CurrentOptions()) do
		if optionData.Id == mapId then
			isValidOption = true
			break
		end
	end

	if not isValidOption then return end

	self.Votes(function(currentVotes)
		local newVotes = table.clone(currentVotes)
		newVotes[player.UserId] = mapId
		return newVotes
	end)
end

-- =============================================================================
--  GAME PHASES
-- =============================================================================

function GameService:RunVotingPhase()
	self.GameStatus("Voting")
	self.TimeLeft(CONFIG.VOTING_TIME)

	-- 1. MapService'den verileri al
	local processedOptions = MapService:GetProcessedVoteOptions(3)
	self.CurrentOptions(processedOptions)
	self.Votes({})

	-- 2. Client'a seçenekleri ve BAŞLANGIÇ SÜRESİNİ gönder
	-- [GÜNCELLENDİ] İkinci parametre olarak süreyi ekledik
	self.Network.VoteOptions:FireAllClients(processedOptions, CONFIG.VOTING_TIME)

	-- Geri Sayım
	for timeRemaining = CONFIG.VOTING_TIME, 1, -1 do
		self.TimeLeft(timeRemaining)
		task.wait(1)
		if #Players:GetPlayers() < CONFIG.MIN_PLAYERS then return nil end
	end

	-- Kazananı Belirle
	local finalCounts = self:_calculateVoteCounts()
	local winnerId = nil
	local maxVotes = -1
	local candidates = {}

	for mapId, voteCount in pairs(finalCounts) do
		if voteCount > maxVotes then
			maxVotes = voteCount
			candidates = {mapId}
		elseif voteCount == maxVotes then
			table.insert(candidates, mapId)
		end
	end

	winnerId = candidates[math.random(1, #candidates)]

	local winnerModule = MapService:FindMapModule(winnerId)
	if not winnerModule and #processedOptions > 0 then
		winnerModule = MapService:FindMapModule(processedOptions[1].Id)
	end

	return winnerModule
end

function GameService:StartGame()
	local activePlayers = Players:GetPlayers()
	if #activePlayers < CONFIG.MIN_PLAYERS then 
		return Promise.reject("Yetersiz Oyuncu") 
	end

	local mapModule = self.NextMapOverride()

	if mapModule then
		self.NextMapOverride(nil) 
		self.GameStatus("Loading")
		task.wait(2)
	else
		mapModule = self:RunVotingPhase()
	end

	if not mapModule then return Promise.reject("Harita seçilemedi") end

	self.GameStatus("Loading")

	local promises = {}
	for _, player in ipairs(activePlayers) do
		table.insert(promises, PlayerService:GetProfile(player))
	end

	return Promise.all(promises):andThen(function()
		local mapData = MapService:LoadMap(mapModule)
		if not mapData then error("Harita yüklenemedi!") end

		if mapData.Lighting then
			self.Network.LoadLighting:FireAllClients(mapData.Lighting)
		end

		self:_setupGameMode(activePlayers)

		self.GameStatus("Warmup")
		self.TimeLeft(CONFIG.WARMUP_TIME)

		self.Network.WarmupStarted:FireAllClients(self.Gamemode(), self.RunningPlayers, CONFIG.WARMUP_TIME)
		self.Signals.WarmupStarted:Fire() 

		SpawnerService:SpawnSurvivors(self.RunningPlayers, mapData.Spawns)
		self:_setupSurvivorMonitoring()

		for timeRemaining = CONFIG.WARMUP_TIME, 1, -1 do
			self.TimeLeft(timeRemaining)
			task.wait(1)
			if #Players:GetPlayers() < CONFIG.MIN_PLAYERS then self:EndGame() return end
		end

		self.GameStatus("InGame")
		SpawnerService:SpawnKillers(self.RunningPlayers, mapData.Spawns)
		self.Network.GameStarted:FireAllClients()
		self.Signals.GameStarted:Fire()

		self:_startTimeLoop()

	end):catch(function(errorMessage)
		warn("Game Start Error:", errorMessage)
		self:EndGame()
	end)
end

function GameService:_setupGameMode(players)
	local modes = GameModesFolder:GetChildren()
	local selectedScript = modes[math.random(1, #modes)]
	local modeModule = require(selectedScript)

	if modeModule.MinPlayers and #players < modeModule.MinPlayers then
		modeModule = require(GameModesFolder.Classic)
		selectedScript = GameModesFolder.Classic
	end

	self._activeModeModule = modeModule
	self.Gamemode(selectedScript.Name)

	local roles = modeModule:Start(self, players)
	self.RunningPlayers = {}

	for player, role in pairs(roles) do
		self.RunningPlayers[player] = Charm.atom(role)

		if role == "Killer" then 
			PlayerService:ResetChance(player)
		elseif role == "Survivor" then 
			PlayerService:AddChance(player, 1) 
		end
	end
end

function GameService:_setupSurvivorMonitoring()
	for player, roleAtom in pairs(self.RunningPlayers) do
		if roleAtom() == "Survivor" then
			local function onCharacterDeath(character)
				local humanoid = character:WaitForChild("Humanoid", 10)
				if humanoid then
					local connection = humanoid.Died:Connect(function()
						if self.GameStatus() == "InGame" and self._activeModeModule then
							self._activeModeModule:OnPlayerDied(self, player)
						end
					end)
					table.insert(self._connections, connection)
				end
			end

			if player.Character then onCharacterDeath(player.Character) end
			local connection = player.CharacterAdded:Connect(onCharacterDeath)
			table.insert(self._connections, connection)
		end
	end
end

function GameService:_startTimeLoop()
	if self._gameLoopTask then task.cancel(self._gameLoopTask) end
	self.TimeLeft(CONFIG.GAME_TIME)

	self._gameLoopTask = task.spawn(function()
		while self.TimeLeft() > 0 do
			task.wait(1)
			self.TimeLeft(self.TimeLeft() - 1)
			if self._activeModeModule and self._activeModeModule.CheckWinCondition then
				if self._activeModeModule:CheckWinCondition(self) then break end
			end
		end
		self:EndGame()
	end)
end

function GameService:EndGame(Executable)
	if self._gameLoopTask then task.cancel(self._gameLoopTask) self._gameLoopTask = nil end
	for _, connection in ipairs(self._connections) do connection:Disconnect() end
	self._connections = {}

	self.GameStatus("Waiting")
	self.Gamemode("Waiting")
	self.TimeLeft(0)
	self._activeModeModule = nil
	self.RunningPlayers = {}
	self.Votes({})
	self.CurrentOptions({})
	self.NextMapOverride(nil)

	self.Network.GameEnded:FireAllClients()
	self.Signals.GameEnded:Fire()

	MapService:Cleanup()
	SpawnerService:DespawnAll()

	if Executable then task.spawn(Executable) end
end

-- =============================================================================
--  INITIALIZATION
-- =============================================================================

function GameService:OnStart()
	local function syncState(stateName, stateAtom)
		Charm.effect(function() 
			self.Network.StateUpdate:FireAllClients(stateName, stateAtom()) 
		end)
	end

	syncState("Gamemode", self.Gamemode)
	syncState("GameStatus", self.GameStatus)
	syncState("TimeLeft", self.TimeLeft)

	Charm.effect(function()
		local voteCounts = self:_calculateVoteCounts()
		self.Network.VoteUpdate:FireAllClients(voteCounts)
	end)

	self.Network.CastVote.OnServerEvent:Connect(function(player, mapId) 
		self:CastVote(player, mapId) 
	end)

	Players.PlayerAdded:Connect(function(player)
		self.Network.StateUpdate:FireClient(player, "Gamemode", self.Gamemode())
		self.Network.StateUpdate:FireClient(player, "GameStatus", self.GameStatus())
		self.Network.StateUpdate:FireClient(player, "TimeLeft", self.TimeLeft())

		-- Late Join Kontrolü
		if self.GameStatus() == "Voting" then
			local currentOptions = self.CurrentOptions()

			if currentOptions and #currentOptions > 0 then
				-- [GÜNCELLENDİ] Late join yapan oyuncuya SUNUCUDAKİ GÜNCEL SÜREYİ gönderiyoruz
				-- self.TimeLeft() o anki saniyeyi (örn: 7) verir.
				self.Network.VoteOptions:FireClient(player, currentOptions, self.TimeLeft())

				task.defer(function()
					if player.Parent then 
						local voteCounts = self:_calculateVoteCounts()
						self.Network.VoteUpdate:FireClient(player, voteCounts)
					end
				end)
			end
		end
	end)

	task.spawn(function()
		while true do
			while #Players:GetPlayers() < CONFIG.MIN_PLAYERS do task.wait(5) end
			task.wait(CONFIG.INTERMISSION)

			local promise = self:StartGame()
			if promise and promise:getStatus() ~= Promise.Status.Rejected then 
				self.Signals.GameEnded:Wait() 
			end
			task.wait(3)
		end
	end)
end

return GameService]]></ProtectedString>
				<string name="ScriptGuid">{16AB58D6-0947-48A1-AF2C-9237A352B3C2}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">GameService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX249EC273203B4431A40FFC0C16DEE355">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Modules = ServerStorage:WaitForChild("Modules")

local ProfileStore = require(Modules:WaitForChild("ProfileStore"))

local Promise = require(Packages:WaitForChild("Promise"))
local Signal = require(Packages:WaitForChild("Signal"))
local Charm = require(Packages:WaitForChild("Charm"))

local Store = ProfileStore.New(RunService:IsStudio() and "Test" or "Live0", {
	CurrencyData = {
		Spent = 0,
		Total = 0,
		Value = 0,
		Name = "Token"
	},
	LevelData = {
		TargetXP = 100,
		ValueXP = 0,
		Level = 1,
		Name = "Level"
	},
	MurdererSkill = "Default"
})

-- Module
local PlayerService = {
	Name = script.Name,
	Client = {},
	
	LoadedPlayers = {}, 
	Signals = {
		PlayerAdded = Signal.new(),
		PlayerRemoved = Signal.new(),
	}
}

--// Client Functions

function PlayerService.Client:GetChance(player)
	return PlayerService:GetChance(player)
end

function PlayerService.Client:GetData(player)
	local success, profile = PlayerService:GetProfile(player):await()
	if success and profile then
		return profile.Data
	else
		warn("Data alınamadı: " .. player.Name)
		return nil
	end
end

--// Server Functions

-- Promise döndüren Async GetProfile
function PlayerService:GetProfile(player)
	return Promise.new(function(resolve, reject)
		local container = self.LoadedPlayers[player]

		if container and container.Profile then
			resolve(container.Profile)
		else
			-- Profil henüz yüklenmemişse veya oyuncu yoksa reject
			reject("Profile not loaded or player not found: " .. player.Name)
		end
	end)
end

function PlayerService:GetChance(player)
	local container = self.LoadedPlayers[player]
	if container and container.Atom then
		return container.Atom()
	end
	return 0 -- Yüklenmediyse 0 döndür
end

function PlayerService:ResetChance(player)
	local container = self.LoadedPlayers[player]
	if container and container.Atom then
		container.Atom(0) -- Şansı sıfırlar
	end
end

function PlayerService:AddChance(player, amount)
	local container = self.LoadedPlayers[player]
	if container and container.Atom then
		amount = amount or 1
		-- Atom'u güncelle (Sadece RAM'de, dataya yazmaz)
		container.Atom(function(current)
			return current + amount
		end)
	end
end

function PlayerService:PlayerLoaded(player)
	local profile = Store:StartSessionAsync("Player_" .. player.UserId)
	if profile ~= nil then
		if player:IsDescendantOf(Players) then
			local chanceAtom = Charm.atom(0)
			self.LoadedPlayers[player] = {
				Profile = profile,
				Atom = chanceAtom
			}
			
			self.Signals.PlayerAdded:Fire(player, profile)
			print(player.Name .. " yüklendi. (Data Template Clean)")
		else
			profile:Release()
		end
	else
		player:Kick("Profile load failed. Please rejoin.")
	end
end

function PlayerService:RemovePlayer(player)
	local container = self.LoadedPlayers[player]
	if container then
		if container.Profile then
			container.Profile:Release()
		end
		self.LoadedPlayers[player] = nil
		self.Signals.PlayerRemoved:Fire(player)
	end
end

function PlayerService:OnStart()
	Players.PlayerAdded:Connect(function(player)
		task.spawn(function()
			self:PlayerLoaded(player)
		end)
	end)
	
	Players.PlayerRemoving:Connect(function(player)
		self:RemovePlayer(player)
	end)
	
	for _, player in ipairs(Players:GetPlayers()) do
		task.spawn(function()
			self:PlayerLoaded(player)
		end)
	end
end

return PlayerService]]></ProtectedString>
				<string name="ScriptGuid">{67893CAD-3B35-493F-AB9E-EA85AB722B92}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">PlayerService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXCCFE25CB3ED64FADB06A33F1A3FF53DE">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Services = ServerStorage:WaitForChild("Services")
local Modules = ServerStorage:WaitForChild("Modules")
local SkillsFolder = Modules:WaitForChild("MurdererSkills")

local Charm = require(Packages:WaitForChild("Charm"))
local Net = require(Packages:WaitForChild("Net"))
local Promise = require(Packages:WaitForChild("Promise"))

local GameService = require(Services:WaitForChild("GameService"))
local PlayerService = require(Services:WaitForChild("PlayerService"))

-- Module
local MurdererService = {
	Name = script.Name,
	Client = {},

	-- Cooldown Takibi (Skill bazlı atom yapısı)
	Cooldowns = {}, 

	Network = {
		ActivateSkill = Net:RemoteEvent("ActivateSkill"),
		CooldownUpdate = Net:RemoteEvent("CooldownUpdate"),
		SkillAssigned = Net:RemoteEvent("SkillAssigned"), -- Survivor ile ortak sinyal yapısı
	}
}

--// Helper
function MurdererService:IsMurderer(player)
	local roleAtom = GameService.RunningPlayers[player]
	return roleAtom and roleAtom() == "Killer"
end

--// Client: Yetenek Kullanma İsteği
function MurdererService:ActivateSkill(player, skillName, mousePosition)
	-- 1. Validasyonlar
	if not self:IsMurderer(player) then return end
	if GameService.Gamemode() == "Waiting" then return end
	if typeof(skillName) ~= "string" then return end
	if mousePosition and typeof(mousePosition) ~= "Vector3" then return end

	-- 2. Datadan Yeteneği Doğrula (Oyuncu gerçekten bu skille mi sahip?)
	PlayerService:GetProfile(player):andThen(function(profile)
		local equippedSkill = profile.Data.MurdererSkill or "Default"

		if skillName ~= equippedSkill then 
			warn(player.Name .. " sahip olmadığı yeteneği kullanmaya çalıştı.")
			return 
		end

		-- 3. Cooldown Kontrolü (Skill Bazlı)
		local currentTime = workspace:GetServerTimeNow()
		if not self.Cooldowns[player] then self.Cooldowns[player] = {} end

		local skillCooldownAtom = self.Cooldowns[player][skillName]
		if skillCooldownAtom and skillCooldownAtom() > currentTime then return end

		-- 4. Modülü Çalıştır
		local skillModuleScript = SkillsFolder:FindFirstChild(skillName) or SkillsFolder:FindFirstChild("Default")

		if skillModuleScript then
			local skillModule = require(skillModuleScript)
			skillModule:Activate(player, GameService, mousePosition)

			-- 5. Cooldown Ayarla
			local cooldownDuration = skillModule.Cooldown or 10
			local finishTime = currentTime + cooldownDuration

			if not self.Cooldowns[player][skillName] then
				self.Cooldowns[player][skillName] = Charm.atom(finishTime)
			else
				self.Cooldowns[player][skillName](finishTime)
			end

			-- Client'a hangi skillin cooldowna girdiğini bildir
			self.Network.CooldownUpdate:FireClient(player, skillName, finishTime)
		end
	end):catch(function(errorMessage)
		warn("Murderer skill hatası: " .. tostring(errorMessage))
	end)
end

--// Server: Oyun başında katilin skill bilgisini client'a gönder
function MurdererService:_initializeMurdererSkill()
	for player, roleAtom in pairs(GameService.RunningPlayers) do
		if roleAtom() == "Killer" then
			PlayerService:GetProfile(player):andThen(function(profile)
				local skillName = profile.Data.MurdererSkill or "Default"
				local skillModuleScript = SkillsFolder:FindFirstChild(skillName) or SkillsFolder:FindFirstChild("Default")

				if skillModuleScript then
					local skillModule = require(skillModuleScript)
					local cooldownTime = skillModule.Cooldown or 10

					-- YENİ: Modüldeki Keybind bilgisini al (Yoksa nil gider)
					local keybind = skillModule.Keybind 

					-- Client'a ismi, cooldown süresini ve tuş atamasını bildir
					self.Network.SkillAssigned:FireClient(player, skillName, cooldownTime, keybind)
				end
			end)
		end
	end
end

function MurdererService:OnStart()
	-- Event Listener (Client -> Server)
	self.Network.ActivateSkill.OnServerEvent:Connect(function(player, skillName, mousePosition)
		self:ActivateSkill(player, skillName, mousePosition)
	end)

	-- Oyun başladığında katilin skillini hazırla
	GameService.Signals.GameStarted:Connect(function()
		self:_initializeMurdererSkill()
	end)

	-- Oyun bittiğinde temizle
	GameService.Signals.GameEnded:Connect(function()
		self.Cooldowns = {}
	end)
end

return MurdererService]]></ProtectedString>
				<string name="ScriptGuid">{E9339E40-B832-4819-B828-65E9982FDB1E}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">MurdererService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXFB6593F33C824226AD7BB9DA5FC1168A">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Services = ServerStorage:WaitForChild("Services")
local Modules = ServerStorage:WaitForChild("Modules")
local SkillsFolder = Modules:WaitForChild("SurvivorSkills")

local Charm = require(Packages:WaitForChild("Charm"))
local Net = require(Packages:WaitForChild("Net"))

local GameService = require(Services:WaitForChild("GameService"))

local SurvivorService = {
	Name = script.Name,
	Client = {},

	-- State
	IsSelectionOpen = false,
	AreSkillsActive = false, 

	SelectedSkills = {}, 
	OfferedSkills = {},  
	Cooldowns = {},      

	Network = {
		SelectSkill = Net:RemoteEvent("SelectSkill"), 
		SkillAssigned = Net:RemoteEvent("SkillAssigned"), 
		ActivateSkill = Net:RemoteEvent("ActivateSkill"), 
		CooldownUpdate = Net:RemoteEvent("CooldownUpdate"),
		SkillOptionsOffered = Net:RemoteEvent("SkillOptionsOffered"), -- Args: (Options, TimeLeft)
	}
}

--// Helper: Oyuncu Survivor mı?
function SurvivorService:IsSurvivor(player)
	local roleAtom = GameService.RunningPlayers[player]
	return roleAtom and roleAtom() == "Survivor"
end

--// YENİ: Tek bir oyuncuya yetenek sunma işlemi (Kod tekrarını önlemek için ayrıldı)
function SurvivorService:_offerSkillsToPlayer(player)
	-- Zaten sunulmuşsa tekrar sunma (Late Join spam koruması)
	if self.OfferedSkills[player] then 
		-- Ama eğer UI'ı açması gerekiyorsa veriyi tekrar gönderebiliriz.
		-- Late Join durumunda UI'ın açılması için veriyi tekrar yollamakta fayda var.
		-- Ancak yeni rastgeleler üretmemeliyiz, eskilerini yollamalıyız.
		-- Şimdilik basit tutuyoruz, eğer listede varsa yeniden hesaplamıyoruz.
	end

	local allSkillsScripts = SkillsFolder:GetChildren()
	if #allSkillsScripts == 0 then return end

	local optionsDataToSend = {} 
	local validOptionNames = {}  
	local usedIndices = {}

	local countToSelect = math.min(3, #allSkillsScripts)

	-- Eğer daha önce oluşturulmuş bir liste varsa (Rejoin durumu) onu kullan
	if self.OfferedSkills[player] then
		validOptionNames = self.OfferedSkills[player]
		-- Bu isimlerin detaylarını tekrar paketle
		for _, name in ipairs(validOptionNames) do
			local scriptObj = SkillsFolder:FindFirstChild(name)
			if scriptObj then
				local success, mod = pcall(require, scriptObj)
				if success and mod then
					table.insert(optionsDataToSend, {
						Name = scriptObj.Name,
						DisplayName = mod.Name or scriptObj.Name,
						Description = mod.Description or "...",
						Image = mod.Image or "",
						Cooldown = mod.Cooldown or 20
					})
				end
			end
		end
	else
		-- Yoksa yeni rastgele oluştur
		while #optionsDataToSend < countToSelect do
			local index = math.random(1, #allSkillsScripts)
			if not usedIndices[index] then
				usedIndices[index] = true
				local skillScript = allSkillsScripts[index]
				local success, skillModule = pcall(require, skillScript)

				if success and skillModule then
					local skillInfo = {
						Name = skillScript.Name,
						DisplayName = skillModule.Name or skillScript.Name,
						Description = skillModule.Description or "No description available.",
						Image = skillModule.Image or "",
						Cooldown = skillModule.Cooldown or 20
					}
					table.insert(optionsDataToSend, skillInfo)
					table.insert(validOptionNames, skillScript.Name)
				else
					warn("Skill modülü yüklenemedi: " .. skillScript.Name)
				end
			end
		end
		-- Hafızaya kaydet
		self.OfferedSkills[player] = validOptionNames
	end

	-- [GÜNCELLENDİ] Client'a Sunucudaki Kalan Süreyi (TimeLeft) gönderiyoruz
	local remainingTime = GameService.TimeLeft()
	self.Network.SkillOptionsOffered:FireClient(player, optionsDataToSend, remainingTime)
end

--// Toplu Sunum (Warmup Başlangıcı)
function SurvivorService:OfferRandomSkills()
	for player, roleAtom in pairs(GameService.RunningPlayers) do
		if roleAtom() == "Survivor" then
			self:_offerSkillsToPlayer(player)
		end
	end
end

--// Client: Skill Seçimi 
function SurvivorService:SelectSkill(player, skillName)
	if not self.IsSelectionOpen then return end
	if not self:IsSurvivor(player) then return end

	local offeredNames = self.OfferedSkills[player]
	if not offeredNames or not table.find(offeredNames, skillName) then
		warn(player.Name .. " hile girişimi: " .. tostring(skillName))
		return
	end

	local skillModuleScript = SkillsFolder:FindFirstChild(skillName)
	if not skillModuleScript then return end

	if not self.SelectedSkills[player] then self.SelectedSkills[player] = {} end
	local playerSkills = self.SelectedSkills[player]

	if #playerSkills >= 1 then return end

	if not table.find(playerSkills, skillName) then
		table.insert(playerSkills, skillName)

		local skillModule = require(skillModuleScript)
		local cooldownTime = skillModule.Cooldown or 20
		local keybind = skillModule.Keybind

		self.Network.SkillAssigned:FireClient(player, skillName, cooldownTime, keybind)
	end
end

--// Server: Otomatik Atama
function SurvivorService:_finalizeSelections()
	self.IsSelectionOpen = false

	for player, roleAtom in pairs(GameService.RunningPlayers) do
		if roleAtom() == "Survivor" then
			if not self.SelectedSkills[player] or #self.SelectedSkills[player] == 0 then
				local offeredNames = self.OfferedSkills[player]
				local skillName

				if offeredNames and #offeredNames > 0 then
					skillName = offeredNames[math.random(1, #offeredNames)]
				else
					local all = SkillsFolder:GetChildren()
					if #all > 0 then skillName = all[math.random(1, #all)].Name end
				end

				if skillName then
					local scriptObj = SkillsFolder:FindFirstChild(skillName)
					if scriptObj then
						local mod = require(scriptObj)
						self.SelectedSkills[player] = { skillName }
						self.Network.SkillAssigned:FireClient(player, skillName, mod.Cooldown or 20, mod.Keybind)
					end
				end
			end
		end
	end
end

--// Client: Skill Kullanımı
function SurvivorService:ActivateSkill(player, skillName, mousePosition)
	if not self.AreSkillsActive then return end 
	if GameService.Gamemode() == "Waiting" then return end
	if not self:IsSurvivor(player) then return end
	if typeof(skillName) ~= "string" then return end

	local targetPos = nil
	if mousePosition then
		if typeof(mousePosition) == "CFrame" then targetPos = mousePosition.Position
		elseif typeof(mousePosition) == "Vector3" then targetPos = mousePosition end
	end

	local playerSkills = self.SelectedSkills[player]
	if not playerSkills or not table.find(playerSkills, skillName) then return end

	local currentTime = workspace:GetServerTimeNow()
	if not self.Cooldowns[player] then self.Cooldowns[player] = {} end

	local atom = self.Cooldowns[player][skillName]
	if atom and atom() > currentTime then return end

	local scriptObj = SkillsFolder:FindFirstChild(skillName)
	if scriptObj then
		local mod = require(scriptObj)
		mod:Activate(player, GameService, targetPos)

		local cd = mod.Cooldown or 20
		local finish = currentTime + cd

		if not self.Cooldowns[player][skillName] then
			self.Cooldowns[player][skillName] = Charm.atom(finish)
		else
			self.Cooldowns[player][skillName](finish)
		end

		self.Network.CooldownUpdate:FireClient(player, skillName, finish)
	end
end

function SurvivorService:OnStart()
	self.Network.SelectSkill.OnServerEvent:Connect(function(plr, name) self:SelectSkill(plr, name) end)
	self.Network.ActivateSkill.OnServerEvent:Connect(function(plr, name, pos) self:ActivateSkill(plr, name, pos) end)

	GameService.Signals.WarmupStarted:Connect(function()
		self.IsSelectionOpen = true
		self.AreSkillsActive = false
		self.SelectedSkills = {}
		self.OfferedSkills = {} 
		self.Cooldowns = {}

		self:OfferRandomSkills() 
		print("SurvivorService: Seçenekler sunuldu.")
	end)

	GameService.Signals.GameStarted:Connect(function()
		self:_finalizeSelections()
		self.AreSkillsActive = true
		print("SurvivorService: Skiller aktif.")
	end)

	GameService.Signals.GameEnded:Connect(function()
		self.IsSelectionOpen = false
		self.AreSkillsActive = false
		self.SelectedSkills = {}
		self.OfferedSkills = {}
		self.Cooldowns = {}
	end)

	-- [GÜNCELLENDİ] Late Join (Sonradan Girenler) İçin Kontrol
	Players.PlayerAdded:Connect(function(player)
		-- Eğer oyun Warmup aşamasındaysa ve bu oyuncu bir Survivor ise (örn: reconnect)
		if GameService.GameStatus() == "Warmup" and self:IsSurvivor(player) then
			-- Seçenekleri o anki süreyle gönder
			self:_offerSkillsToPlayer(player)
		end
	end)
end

return SurvivorService]]></ProtectedString>
				<string name="ScriptGuid">{49B839C4-3737-48BC-ADD4-EBB477D06EF6}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">SurvivorService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX2A2D85BCF90743BDA285060E25D4093F">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserService = game:GetService("UserService")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")

local Signal = require(Packages:WaitForChild("Signal"))
local Charm = require(Packages:WaitForChild("Charm"))
local Net = require(Packages:WaitForChild("Net"))
local Promise = require(Packages:WaitForChild("Promise"))

-- Constants
local Shared = ReplicatedStorage:WaitForChild("Shared")
local MapsFolder = Shared:WaitForChild("Maps")

local MapService = {
	Name = script.Name,
	Client = {},

	CurrentMapInstance = nil,
	CurrentMapData = Charm.atom(nil), -- { Name, Authors, Module }

	Signals = {
		MapLoaded = Signal.new(),
		MapUnloaded = Signal.new()
	},

	Network = {
		MapLoaded = Net:RemoteEvent("MapLoaded"),
		MapUnloaded = Net:RemoteEvent("MapUnloaded")
	}
}

--// SERVER: Mevcut haritayı döndür
function MapService:GetMap()
	return self.CurrentMapInstance, self.CurrentMapData()
end

--// CLIENT: Client erişimi
function MapService.Client:GetMap(player)
	return self.Server:GetMap()
end

--// YARDIMCI: İsimden Modül Bulma
function MapService:FindMapModule(mapName)
	for _, moduleInstance in ipairs(MapsFolder:GetChildren()) do
		if moduleInstance.Name == mapName then
			return moduleInstance
		end
	end
	return nil
end

--// YENİ: Tam İşlenmiş Oylama Verisi Getir (Promise ile)
function MapService:GetProcessedVoteOptions(count)
	local allMaps = MapsFolder:GetChildren()
	local selectedModules = {}
	local usedIndices = {}

	-- 1. Rastgele Modülleri Seç
	local amountToSelect = math.min(count, #allMaps)
	while #selectedModules < amountToSelect do
		local randomIndex = math.random(1, #allMaps)
		if not usedIndices[randomIndex] then
			usedIndices[randomIndex] = true
			table.insert(selectedModules, allMaps[randomIndex])
		end
	end

	-- 2. Verileri İşle
	local promises = {}

	for _, mapModule in ipairs(selectedModules) do
		table.insert(promises, Promise.new(function(resolve)
			local success, moduleData = pcall(require, mapModule)

			-- Varsayılan Veri Şablonu
			local processedData = {
				Id = mapModule.Name,
				Name = mapModule.Name,
				Description = "No description available.",
				Image = "",
				Authors = {}
			}

			if success and moduleData then
				processedData.Name = moduleData.Name or processedData.Name
				processedData.Description = moduleData.Description or processedData.Description
				processedData.Image = moduleData.Image or processedData.Image

				-- Yazar İsimlerini Çek (Async)
				if moduleData.Authors and #moduleData.Authors > 0 then
					local pcallSuccess, userInfos = pcall(function()
						return UserService:GetUserInfosByUserIdsAsync(moduleData.Authors)
					end)

					if pcallSuccess and userInfos then
						for _, userInfo in ipairs(userInfos) do
							table.insert(processedData.Authors, userInfo.DisplayName)
						end
					end
				end
			else
				warn("MapService: Modül require edilemedi ->", mapModule.Name)
			end

			resolve(processedData)
		end))
	end

	-- Tüm verilerin hazırlanmasını bekle
	local success, results = Promise.all(promises):await()

	if success then
		return results
	else
		warn("MapService: Oylama verileri hazırlanırken hata oluştu.")
		return {}
	end
end

--// ÇEKİRDEK: Haritayı Yükle
function MapService:LoadMap(mapModule)
	self:Cleanup() 

	local success, mapData = pcall(require, mapModule)
	if not success or not mapData or not mapData.Map then
		warn("Map Yükleme Hatası:", mapModule.Name)
		return nil
	end

	local newMapInstance = mapData.Map:Clone()
	newMapInstance.Name = "CurrentMap"
	newMapInstance.Parent = Workspace
	self.CurrentMapInstance = newMapInstance

	-- Yazar isimlerini asenkron yükle (UI güncellemesi için)
	local displayAuthors = {"Loading..."}

	task.spawn(function()
		if mapData.Authors then
			local pcallSuccess, userInfos = pcall(function() 
				return UserService:GetUserInfosByUserIdsAsync(mapData.Authors) 
			end)

			if pcallSuccess and userInfos then
				local authorNames = {}
				for _, userInfo in ipairs(userInfos) do 
					table.insert(authorNames, userInfo.DisplayName) 
				end

				-- State atomunu güncelle
				self.CurrentMapData(function(currentData) 
					if currentData and currentData.Module == mapModule then 
						local newData = table.clone(currentData)
						newData.Authors = authorNames
						return newData 
					end 
					return currentData 
				end)
			end
		end
	end)

	self.CurrentMapData({
		Name = mapData.Name,
		Authors = displayAuthors, 
		Module = mapModule
	})

	self.Signals.MapLoaded:Fire(newMapInstance, mapData)
	self.Network.MapLoaded:FireAllClients(mapData.Name, mapData.Lighting)

	return {
		Spawns = self:GetSpawns(),
		Lighting = mapData.Lighting
	}
end

function MapService:Cleanup()
	if self.CurrentMapInstance then
		self.Signals.MapUnloaded:Fire()
		self.Network.MapUnloaded:FireAllClients()
		self.CurrentMapInstance:Destroy()
		self.CurrentMapInstance = nil
	end
	self.CurrentMapData(nil)
end

function MapService:GetSpawns()
	if not self.CurrentMapInstance then return {} end

	local spawnsFolder = self.CurrentMapInstance:FindFirstChild("Spawns")
	if spawnsFolder then return spawnsFolder:GetChildren() end

	local spawns = {}
	for _, descendant in ipairs(self.CurrentMapInstance:GetDescendants()) do
		if descendant:IsA("SpawnLocation") then 
			table.insert(spawns, descendant) 
		end
	end
	return spawns
end

function MapService:OnStart()
	
end

return MapService]]></ProtectedString>
				<string name="ScriptGuid">{AFFD8432-9DA3-4E0F-8912-0189DF6E09FE}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">MapService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX62DEA3B59DAB41D595DD4AF3FEDB8DB4">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local Players = game:GetService("Players")

local SpawnerService = {
	Name = script.Name,
	Client = {},
}

-- Survivorları Spawnla (Warmup Aşaması)
function SpawnerService:SpawnSurvivors(runningPlayers, spawnLocations)
	for player, roleAtom in pairs(runningPlayers) do
		if roleAtom() == "Survivor" then
			self:_spawnPlayer(player, spawnLocations)
		end
	end
end

-- Katilleri Spawnla (Oyun Başlangıcı)
function SpawnerService:SpawnKillers(runningPlayers, spawnLocations)
	for player, roleAtom in pairs(runningPlayers) do
		if roleAtom() == "Killer" then
			self:_spawnPlayer(player, spawnLocations)
		end
	end
end

-- Herkesi Lobiye Gönder (Reset)
function SpawnerService:DespawnAll()
	for _, player in ipairs(Players:GetPlayers()) do
		player.RespawnLocation = nil
		player:LoadCharacterAsync()
	end
end

--// Internal Helper
function SpawnerService:_spawnPlayer(player: Player, spawnLocations)
	if not player then return end

	if spawnLocations and #spawnLocations > 0 then
		local randomSpawn = spawnLocations[math.random(1, #spawnLocations)]

		-- 1. RespawnLocation'ı ayarla (Doğal Roblox spawnı için)
		player.RespawnLocation = randomSpawn

		-- 2. Işınlama garantisi (Karakter yüklendiği an tam konuma çekmek için)
		local connection
		connection = player.CharacterAdded:Connect(function(character)
			local rootPart = character:WaitForChild("HumanoidRootPart", 5)
			if rootPart then
				-- PivotTo ile direkt spawn CFrame'ine ışınlıyoruz
				character:PivotTo(randomSpawn.CFrame * CFrame.new(0, 3, 0))
			end
			connection:Disconnect() -- Sadece bir kez çalışması için
		end)
	end

	-- 3. Karakteri yükle
	player:LoadCharacterAsync()
end

return SpawnerService]]></ProtectedString>
				<string name="ScriptGuid">{A11CA0A5-5886-4499-B671-7FE8BA3DD414}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">SpawnerService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>