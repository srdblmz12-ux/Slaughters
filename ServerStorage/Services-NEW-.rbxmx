<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXE81B415527EA4B979F7AD3DB50C10C64">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">Services</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXCD9112015AA24DFDA5F984912D6F77B8">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")

-- Variables
local Shared = ReplicatedStorage:WaitForChild("Shared")
local Services = ServerStorage:WaitForChild("Services")
local ShopAssets = Shared:WaitForChild("ShopAssets")

local DataService = require(Services:WaitForChild("DataService"))
local MonetizationService = require(Services:WaitForChild("MonetizationService"))

-- ZORUNLU SLOTLAR: Bunlar Unequip edilemez, sadece değiştirilebilir.
local MANDATORY_SLOTS = {
	["KillerSkin"] = true,
}

local ShopService = {
	Name = "ShopService",
	Client = {},
	ItemList = {} 
}

--// Helper Functions

function ShopService:ProcessPurchase(player, itemName)
	local itemData = self.ItemList[itemName]
	if not itemData then return false, "Item not found" end

	local profileData = DataService:GetData(player)
	if not profileData then return false, "Data loading..." end

	local categoryName = itemData.DataCategory or itemData.Category

	-- Sahiplik Kontrolü
	if self:UserHas(player, categoryName, itemName) then
		return false, "Already owned"
	end

	-- Para Kontrolü
	local price = itemData.Price or 0
	local currentMoney = profileData.CurrencyData.Value

	if currentMoney >= price then
		-- 1. Parayı Düş
		DataService:UpdateValue(player, "CurrencyData.Value", -price)

		-- 2. Eşyayı Ver
		DataService:SetDictionaryItem(player, categoryName, itemName, true)

		print(player.Name .. " bought: " .. itemName)
		return true, "Successfully purchased!"
	else
		return false, "Not enough Token!"
	end
end

function ShopService:ProcessEquip(player, itemName)
	local itemData = self.ItemList[itemName]
	if not itemData then return false, "Item not found" end

	local profileData = DataService:GetData(player)
	if not profileData then return false, "Data loading..." end

	-- Sahiplik Kontrolü
	local categoryName = itemData.DataCategory or itemData.Category
	if not self:UserHas(player, categoryName, itemName) then
		return false, "You don't own this!"
	end

	local equipSlot = itemData.EquipSlot
	if not equipSlot then return false, "Not equippable" end

	local currentEquipped = profileData.Equippeds[equipSlot]
	local isMandatory = MANDATORY_SLOTS[equipSlot]

	-- Mantık: Takılı olanla aynı mı?
	if currentEquipped == itemName then
		-- Zaten takılıysa
		if isMandatory then
			return false, "Cannot unequip base item!" -- Skin çıkarılamaz
		else
			DataService:SetValue(player, "Equippeds." .. equipSlot, "") 
			return true, "Unequipped"
		end
	else
		-- Farklıysa değiştir
		DataService:SetValue(player, "Equippeds." .. equipSlot, itemName)
		return true, "Equipped"
	end
end

function ShopService:UserHas(player, category, itemName)
	local profileData = DataService:GetData(player)
	if not profileData then return false end

	if profileData[category] and profileData[category][itemName] then
		return true
	end
	return false
end

--// Client Functions

function ShopService.Client:Purchase(player, itemName)
	return ShopService:ProcessPurchase(player, itemName)
end

function ShopService.Client:EquipItem(player, itemName)
	return ShopService:ProcessEquip(player, itemName)
end

function ShopService.Client:GetItemData(player, itemName)
	return ShopService.ItemList[itemName]
end

function ShopService:OnStart()
	-- 15000 Tokens
	MonetizationService:Register(MonetizationService.Type.Product, 3530798246, function(Player : Player)
		local Amount = 15000
		DataService:UpdateValue(Player, "CurrencyData.Value", Amount)
	end)

	-- 3500 Tokens
	MonetizationService:Register(MonetizationService.Type.Product, 3530798247, function(Player : Player)
		local Amount = 3500
		DataService:UpdateValue(Player, "CurrencyData.Value", Amount)
	end)

	-- 1500 Tokens
	MonetizationService:Register(MonetizationService.Type.Product, 3530798248, function(Player : Player)
		local Amount = 1500
		DataService:UpdateValue(Player, "CurrencyData.Value", Amount)
	end)

	-- 500 Tokens
	MonetizationService:Register(MonetizationService.Type.Product, 3530798249, function(Player : Player)
		local Amount = 500
		DataService:UpdateValue(Player, "CurrencyData.Value", Amount)
	end)
	
	-- Assets Yükleyici
	for _, CategoryFolder in ipairs(ShopAssets:GetChildren()) do
		for _, Item in ipairs(CategoryFolder:GetChildren()) do
			if (Item:IsA("ModuleScript")) then
				local Success, ModuleData = pcall(require, Item)
				if (Success) then
					self.ItemList[Item.Name] = ModuleData

					-- Kategori Yaması (Eğer modülde yoksa klasör adını al)
					if not ModuleData.Category and not ModuleData.DataCategory then
						ModuleData.Category = CategoryFolder.Name
					end
				else
					warn("ShopService Load Fail: " .. Item.Name)
				end
			end
		end
	end
end

return ShopService]]></ProtectedString>
				<string name="ScriptGuid">{6061ec31-3c7a-41dd-97a5-1319a064d1dd}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ShopService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX30B78BAD8CA64DAB95EC859906B95EE2">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Modules = ServerStorage:WaitForChild("Modules")

local ProfileStore = require(Modules:WaitForChild("ProfileStore"))
local OrderedStore = require(Modules:WaitForChild("OrderedStore"))
local Promise = require(Packages:WaitForChild("Promise"))
local Signal = require(Packages:WaitForChild("Signal"))
local Net = require(Packages:WaitForChild("Net"))

-- Profile Template
local PROFILE_TEMPLATE = {
	CurrencyData = {
		Spent = 0,
		Total = 0,
		Value = 0, -- Token Miktarı
		Name = "Token"
	},
	Wins = {
		Wins = 0,
	},
	KillerSkins = {
		["Bloxxer"] = true
	},
	KillerSkills = {},
	Equippeds = {
		KillerSkin = "Bloxxer",
		KillerSkill = "",
	},
	MurdererSkill = "Default"
}

local Store = ProfileStore.New(RunService:IsStudio() and "Test" or "Live1", PROFILE_TEMPLATE)

-- Service Definition
local DataService = {
	Name = "DataService",
	Client = {},
	LoadedProfiles = {},

	-- Dışarıdan erişilebilir Leaderboard nesneleri
	Leaderboards = {
		Token = OrderedStore.new("GlobalTokenLB", "CurrencyData.Value", 10),
		Level = OrderedStore.new("GlobalLevelLB", "LevelData.Level", 10)
	},

	Signals = {
		ProfileLoaded = Signal.new(),
		ProfileReleased = Signal.new(),
		DataUpdate = Signal.new() -- [YENİ] Sunucu içi veri değişim sinyali
	},
	Network = {
		DataUpdate = Net:RemoteEvent("DataUpdate") -- Client için
	}
}

--// Helper Functions

local function GetTablePath(root, path)
	local parts = string.split(path, ".")
	local current = root
	for i = 1, #parts - 1 do
		current = current[parts[i]]
		if not current then return nil, nil end
	end
	return current, parts[#parts]
end

--// Client Functions

function DataService.Client:GetData(player)
	return DataService:GetData(player)
end

--// Server Functions

function DataService:SetValue(player, path, value)
	local profile = self.LoadedProfiles[player]
	if not profile then return end

	local dataTable, key = GetTablePath(profile.Data, path)

	if dataTable and key then
		dataTable[key] = value

		-- 1. Client'a bildir (GUI güncellemesi için)
		self.Network.DataUpdate:FireClient(player, path, value)

		-- 2. Server'a bildir (Leaderstats ve diğer sistemler için) [YENİ]
		self.Signals.DataUpdate:Fire(player, path, value)
	end
end

function DataService:UpdateValue(player, path, callbackOrAmount)
	local profile = self.LoadedProfiles[player]
	if not profile then return end

	local dataTable, key = GetTablePath(profile.Data, path)

	if dataTable and key then
		local oldValue = dataTable[key]
		local newValue

		if type(callbackOrAmount) == "number" and type(oldValue) == "number" then
			newValue = oldValue + callbackOrAmount
		elseif type(callbackOrAmount) == "function" then
			newValue = callbackOrAmount(oldValue)
		else
			newValue = callbackOrAmount
		end

		dataTable[key] = newValue

		-- 1. Client'a bildir
		self.Network.DataUpdate:FireClient(player, path, newValue)

		-- 2. Server'a bildir [YENİ]
		self.Signals.DataUpdate:Fire(player, path, newValue)

		return newValue
	end
end

function DataService:SetDictionaryItem(player, path, key, value)
	local profile = self.LoadedProfiles[player]
	if not profile then return end

	local dataTable, pathKey = GetTablePath(profile.Data, path)

	if dataTable and pathKey then
		local targetTable = dataTable[pathKey]
		if targetTable and type(targetTable) == "table" then
			targetTable[key] = value

			-- 1. Client'a bildir
			self.Network.DataUpdate:FireClient(player, path, targetTable)

			-- 2. Server'a bildir (Tüm tabloyu gönderiyoruz) [YENİ]
			self.Signals.DataUpdate:Fire(player, path, targetTable)
		end
	end
end

function DataService:GetData(player)
	local profile = self.LoadedProfiles[player]
	if profile then return profile.Data end

	local maxRetries = 100
	local attempts = 0
	while player:IsDescendantOf(Players) and attempts < maxRetries do
		attempts += 1
		profile = self.LoadedProfiles[player]
		if profile then return profile.Data end
		task.wait(0.1)
	end
	return nil
end

function DataService:GetProfile(player)
	return Promise.new(function(resolve, reject)
		local profile = self.LoadedProfiles[player]
		if profile then
			resolve(profile)
		else
			reject("Profile not loaded for: " .. player.Name)
		end
	end)
end

function DataService:LoadProfile(player)
	local profile = Store:StartSessionAsync("Player_" .. player.UserId, {
		Cancel = function() return player.Parent ~= Players end,
	})

	if profile ~= nil then
		profile:AddUserId(player.UserId)
		profile:Reconcile()

		profile.OnSessionEnd:Connect(function()
			self.LoadedProfiles[player] = nil
			for _, leaderboard in pairs(self.Leaderboards) do
				leaderboard:RemoveProfile(player)
			end
			player:Kick("Session ended.") 
		end)

		if player:IsDescendantOf(Players) then
			self.LoadedProfiles[player] = profile

			for _, leaderboard in pairs(self.Leaderboards) do
				leaderboard:AddProfile(player, profile)
			end

			self.Signals.ProfileLoaded:Fire(player, profile)
		else
			profile:EndSession()
		end
	else
		player:Kick("Profile load failed.")
	end
end

function DataService:ReleaseProfile(player)
	local profile = self.LoadedProfiles[player]
	if profile then
		for _, leaderboard in pairs(self.Leaderboards) do
			leaderboard:RemoveProfile(player)
		end

		profile:EndSession()
		self.LoadedProfiles[player] = nil
		self.Signals.ProfileReleased:Fire(player)
	end
end

function DataService:OnStart()
	Players.PlayerAdded:Connect(function(player) self:LoadProfile(player) end)
	Players.PlayerRemoving:Connect(function(player) self:ReleaseProfile(player) end)

	for _, player in ipairs(Players:GetPlayers()) do
		task.spawn(function() self:LoadProfile(player) end)
	end

	task.spawn(function()
		while true do
			task.wait(10)
			for key, leaderboard in pairs(self.Leaderboards) do
				leaderboard:Refresh()
			end
		end
	end)
end

game:BindToClose(function()
	for _, player in ipairs(Players:GetPlayers()) do
		local profile = DataService.LoadedProfiles[player]
		if profile then profile:EndSession() end
	end
	task.wait(2)
end)

return DataService]]></ProtectedString>
				<string name="ScriptGuid">{C3C988C6-8B11-4869-8EA6-7096D58EB9D8}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">DataService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX7B618A8EDD9844248135D448A9CE5A79">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserService = game:GetService("UserService")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")

local Signal = require(Packages:WaitForChild("Signal"))
local Charm = require(Packages:WaitForChild("Charm"))
local Net = require(Packages:WaitForChild("Net"))
local Promise = require(Packages:WaitForChild("Promise"))

-- Constants
local Shared = ReplicatedStorage:WaitForChild("Shared")
local MapsFolder = Shared:WaitForChild("Maps")

local MapService = {
	Name = script.Name,
	Client = {},

	CurrentMapInstance = nil,
	CurrentMapData = Charm.atom(nil),

	Signals = {
		MapLoaded = Signal.new(),
		MapUnloaded = Signal.new()
	},

	Network = {
		MapLoaded = Net:RemoteEvent("MapLoaded"),
		MapUnloaded = Net:RemoteEvent("MapUnloaded")
	}
}

--// SERVER: Mevcut haritayı döndür
function MapService:GetMap()
	return self.CurrentMapInstance, self.CurrentMapData()
end

--// CLIENT: Client erişimi
function MapService.Client:GetMap(player)
	return self.Server:GetMap()
end

--// YARDIMCI: İsimden Modül Bulma
function MapService:FindMapModule(mapName)
	for _, moduleInstance in ipairs(MapsFolder:GetChildren()) do
		if moduleInstance.Name == mapName then
			return moduleInstance
		end
	end
	return nil
end

--// Oylama Verisi Getir
function MapService:GetProcessedVoteOptions(count)
	local allMaps = MapsFolder:GetChildren()
	local selectedModules = {}
	local usedIndices = {}

	local amountToSelect = math.min(count, #allMaps)
	while #selectedModules < amountToSelect do
		local randomIndex = math.random(1, #allMaps)
		if not usedIndices[randomIndex] then
			usedIndices[randomIndex] = true
			table.insert(selectedModules, allMaps[randomIndex])
		end
	end

	local promises = {}

	for _, mapModule in ipairs(selectedModules) do
		table.insert(promises, Promise.new(function(resolve)
			local success, moduleData = pcall(require, mapModule)

			local processedData = {
				Id = mapModule.Name,
				Name = mapModule.Name,
				Description = "No description available.",
				Image = "",
				Authors = {}
			}

			if success and moduleData then
				processedData.Name = moduleData.Name or processedData.Name
				processedData.Description = moduleData.Description or processedData.Description
				processedData.Image = moduleData.Image or processedData.Image

				if moduleData.Authors and #moduleData.Authors > 0 then
					local pcallSuccess, userInfos = pcall(function()
						return UserService:GetUserInfosByUserIdsAsync(moduleData.Authors)
					end)

					if pcallSuccess and userInfos then
						for _, userInfo in ipairs(userInfos) do
							table.insert(processedData.Authors, userInfo.DisplayName)
						end
					end
				end
			else
				warn("MapService: Modül require edilemedi ->", mapModule.Name)
			end

			resolve(processedData)
		end))
	end

	local success, results = Promise.all(promises):await()

	if success then
		return results
	else
		warn("MapService: Oylama verileri hazırlanırken hata oluştu.")
		return {}
	end
end

--// ÇEKİRDEK: Haritayı Yükle (GÜNCELLENDİ: INSTANCE SAYISI KONTROLÜ)
function MapService:LoadMap(mapModule)
	self:Cleanup() 

	local success, mapData = pcall(require, mapModule)
	if not success or not mapData or not mapData.Map then
		warn("Map Yükleme Hatası:", mapModule.Name)
		return nil
	end

	local sourceMap = mapData.Map
	-- 1. Hedef Sayıyı Al: Orijinal haritada kaç tane nesne (Part, Script vs.) var?
	local expectedDescendantCount = #sourceMap:GetDescendants()

	-- 2. Haritayı Kopyala
	local newMapInstance = sourceMap:Clone()
	newMapInstance.Name = "CurrentMap"
	newMapInstance.Parent = Workspace
	self.CurrentMapInstance = newMapInstance

	-- 3. [KONTROL DÖNGÜSÜ] Tüm instanceler Workspace'e geçti mi?
	-- Kopyalanan haritanın içindeki nesne sayısı, orijinalle aynı olana kadar bekle.
	local startTime = os.clock()
	local isFullyLoaded = false

	repeat
		local currentCount = #newMapInstance:GetDescendants()

		if currentCount >= expectedDescendantCount then
			isFullyLoaded = true
		else
			-- Henüz tüm parçalar oluşmadıysa bekle
			task.wait()
		end

		-- Sonsuz döngüye girmemesi için 5 saniyelik güvenlik timeout'u
	until isFullyLoaded or (os.clock() - startTime > 5)

	if not isFullyLoaded then
		warn("MapService UYARI: Harita kopyalandı ama parça sayıları eşleşmedi! (Beklenen: " .. expectedDescendantCount .. ", Bulunan: " .. #newMapInstance:GetDescendants() .. ")")
	end

	-- 4. Varsa Init Fonksiyonu
	if type(mapData.Init) == "function" then
		pcall(function() mapData.Init(newMapInstance) end)
	end

	-- 5. Yazarları Yükle
	local displayAuthors = {"Loading..."}
	task.spawn(function()
		if mapData.Authors then
			local pcallSuccess, userInfos = pcall(function() 
				return UserService:GetUserInfosByUserIdsAsync(mapData.Authors) 
			end)

			if pcallSuccess and userInfos then
				local authorNames = {}
				for _, userInfo in ipairs(userInfos) do 
					table.insert(authorNames, userInfo.DisplayName) 
				end

				self.CurrentMapData(function(currentData) 
					if currentData and currentData.Module == mapModule then 
						local newData = table.clone(currentData)
						newData.Authors = authorNames
						return newData 
					end 
					return currentData 
				end)
			end
		end
	end)

	-- 6. State Güncelle
	self.CurrentMapData({
		Name = mapData.Name,
		Authors = displayAuthors, 
		Module = mapModule
	})

	-- 7. Sinyalleri Ateşle (Tamamlandı)
	self.Signals.MapLoaded:Fire(newMapInstance, mapData)
	self.Network.MapLoaded:FireAllClients(mapData.Name, mapData.Lighting)

	return {
		Spawns = self:GetSpawns(),
		Lighting = mapData.Lighting
	}
end

--// Temizlik
function MapService:Cleanup()
	self.Signals.MapUnloaded:Fire()
	self.Network.MapUnloaded:FireAllClients()

	if self.CurrentMapInstance then
		self.CurrentMapInstance:Destroy()
		self.CurrentMapInstance = nil
	end
	self.CurrentMapData(nil)
end

function MapService:GetSpawns()
	if not self.CurrentMapInstance then return {} end

	local spawnsFolder = self.CurrentMapInstance:FindFirstChild("Spawns")
	if spawnsFolder then return spawnsFolder:GetChildren() end

	local spawns = {}
	for _, descendant in ipairs(self.CurrentMapInstance:GetDescendants()) do
		if descendant:IsA("SpawnLocation") then 
			table.insert(spawns, descendant) 
		end
	end
	return spawns
end

function MapService:OnStart() end

return MapService]]></ProtectedString>
				<string name="ScriptGuid">{AFFD8432-9DA3-4E0F-8912-0189DF6E09FE}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">MapService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXBC38CFD762D4464FB224EEEE44F3CDFE">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Services = ServerStorage:WaitForChild("Services")
local Modules = ServerStorage:WaitForChild("Modules")
local SkillsFolder = Modules:WaitForChild("SurvivorSkills")

local Charm = require(Packages:WaitForChild("Charm"))
local Net = require(Packages:WaitForChild("Net"))

local GameService = require(Services:WaitForChild("GameService"))

local SurvivorService = {
	Name = script.Name,
	Client = {},

	IsSelectionOpen = false,
	AreSkillsActive = false, 

	SelectedSkills = {}, 
	OfferedSkills = {},  
	Cooldowns = {},      

	Network = {
		SelectSkill = Net:RemoteEvent("SelectSkill"), 
		SkillAssigned = Net:RemoteEvent("SkillAssigned"), 
		ActivateSkill = Net:RemoteEvent("ActivateSkill"), 
		CooldownUpdate = Net:RemoteEvent("CooldownUpdate"),
		SkillOptionsOffered = Net:RemoteEvent("SkillOptionsOffered"),
	}
}

-- [DÜZELTME 1] UserId ile Rol Kontrolü
function SurvivorService:IsSurvivor(player)
	local uid = tostring(player.UserId)
	local role = GameService.RunningPlayers[uid]
	return role == "Survivor"
end

function SurvivorService:_offerSkillsToPlayer(player)
	local allSkillsScripts = SkillsFolder:GetChildren()
	if #allSkillsScripts == 0 then return end

	local optionsDataToSend = {} 
	local validOptionNames = {}  
	local usedIndices = {}

	local countToSelect = math.min(3, #allSkillsScripts)

	while #validOptionNames < countToSelect do
		local index = math.random(1, #allSkillsScripts)
		if not usedIndices[index] then
			usedIndices[index] = true
			local skillScript = allSkillsScripts[index]
			local success, skillModule = pcall(require, skillScript)

			if success and skillModule then
				table.insert(validOptionNames, skillScript.Name)
				table.insert(optionsDataToSend, {
					Name = skillScript.Name,
					DisplayName = skillModule.Name or skillScript.Name,
					Description = skillModule.Description or "...",
					Image = skillModule.Image or "",
					Cooldown = skillModule.Cooldown or 20
				})
			end
		end
	end

	self.OfferedSkills[player] = validOptionNames
	local remainingTime = GameService.TimeLeft()
	self.Network.SkillOptionsOffered:FireClient(player, optionsDataToSend, remainingTime)
end

function SurvivorService:OfferRandomSkills()
	-- [DÜZELTME 2] Döngüde UserId -> Player dönüşümü
	for userIdStr, role in pairs(GameService.RunningPlayers) do
		if role == "Survivor" then
			local player = Players:GetPlayerByUserId(tonumber(userIdStr))
			if player then
				self:_offerSkillsToPlayer(player)
			end
		end
	end
end

function SurvivorService:SelectSkill(player, skillName)
	if not self.IsSelectionOpen then return end
	if not self:IsSurvivor(player) then return end
	if self.SelectedSkills[player] then return end 

	local offered = self.OfferedSkills[player]
	if not offered or not table.find(offered, skillName) then return end

	local skillModuleScript = SkillsFolder:FindFirstChild(skillName)
	if not skillModuleScript then return end

	self.SelectedSkills[player] = skillName

	local mod = require(skillModuleScript)
	self.Network.SkillAssigned:FireClient(player, skillName, mod.Cooldown or 20, mod.Keybind)
end

function SurvivorService:_finalizeSelections()
	self.IsSelectionOpen = false

	-- [DÜZELTME 3] Döngüde UserId -> Player dönüşümü
	for userIdStr, role in pairs(GameService.RunningPlayers) do
		local player = Players:GetPlayerByUserId(tonumber(userIdStr))

		if player and role == "Survivor" and not self.SelectedSkills[player] then
			local offered = self.OfferedSkills[player]
			local finalChoice = nil

			if offered and #offered > 0 then
				finalChoice = offered[math.random(1, #offered)]
			end

			if finalChoice then
				local scriptObj = SkillsFolder:FindFirstChild(finalChoice)
				if scriptObj then
					local mod = require(scriptObj)
					self.SelectedSkills[player] = finalChoice
					self.Network.SkillAssigned:FireClient(player, finalChoice, mod.Cooldown or 20, mod.Keybind)
				end
			end
		end
	end
end

function SurvivorService:ActivateSkill(player, skillName, mousePosition)
	if not self.AreSkillsActive then return end 
	if not self:IsSurvivor(player) then return end

	if self.SelectedSkills[player] ~= skillName then return end

	local currentTime = workspace:GetServerTimeNow()
	self.Cooldowns[player] = self.Cooldowns[player] or {}

	local atom = self.Cooldowns[player][skillName]
	if atom and atom() > currentTime then return end

	local scriptObj = SkillsFolder:FindFirstChild(skillName)
	if scriptObj then
		local mod = require(scriptObj)

		local targetPos = nil
		if typeof(mousePosition) == "CFrame" then targetPos = mousePosition.Position
		elseif typeof(mousePosition) == "Vector3" then targetPos = mousePosition end

		mod:Activate(player, GameService, targetPos)

		local cd = mod.Cooldown or 20
		local finish = currentTime + cd

		if not atom then
			self.Cooldowns[player][skillName] = Charm.atom(finish)
		else
			self.Cooldowns[player][skillName](finish)
		end

		self.Network.CooldownUpdate:FireClient(player, skillName, finish)
	end
end

function SurvivorService:OnStart()
	self.Network.SelectSkill.OnServerEvent:Connect(function(plr, name) self:SelectSkill(plr, name) end)
	self.Network.ActivateSkill.OnServerEvent:Connect(function(plr, name, pos) self:ActivateSkill(plr, name, pos) end)

	GameService.Signals.WarmupStarted:Connect(function()
		self.IsSelectionOpen = true
		self.AreSkillsActive = false
		self.SelectedSkills = {}
		self.OfferedSkills = {} 
		self.Cooldowns = {}
		self:OfferRandomSkills() 
	end)

	GameService.Signals.GameStarted:Connect(function()
		self:_finalizeSelections()
		self.AreSkillsActive = true
	end)

	GameService.Signals.GameEnded:Connect(function()
		self.IsSelectionOpen = false
		self.AreSkillsActive = false
		self.SelectedSkills = {}
		self.OfferedSkills = {}
		self.Cooldowns = {}
	end)

	Players.PlayerAdded:Connect(function(player)
		if GameService.GameStatus() == "Warmup" and self:IsSurvivor(player) then
			self:_offerSkillsToPlayer(player)
		end
	end)
end

return SurvivorService]]></ProtectedString>
				<string name="ScriptGuid">{49B839C4-3737-48BC-ADD4-EBB477D06EF6}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">SurvivorService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXA43A077C357248889F538B67626930AF">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Shared = ReplicatedStorage:WaitForChild("Shared")

local Services = ServerStorage:WaitForChild("Services")
local Modules = ServerStorage:WaitForChild("Modules")

local MurdererSkillsFolder = Modules:WaitForChild("MurdererSkills")
local MainAttackModule = MurdererSkillsFolder:WaitForChild("Attack") -- Ana Saldırı Scripti
local SecondarySkillsFolder = MurdererSkillsFolder:WaitForChild("Skills") -- Diğer Skillerin Klasörü

local Charm = require(Packages:WaitForChild("Charm"))
local Net = require(Packages:WaitForChild("Net"))
local Promise = require(Packages:WaitForChild("Promise"))

local GameService = require(Services:WaitForChild("GameService"))
local DataService = require(Services:WaitForChild("DataService"))

local MurdererService = {
	Name = script.Name,
	Client = {},

	Cooldowns = {}, 

	Network = {
		ActivateSkill = Net:RemoteEvent("ActivateSkill"),
		CooldownUpdate = Net:RemoteEvent("CooldownUpdate"),
		SkillAssigned = Net:RemoteEvent("SkillAssigned"), 
		PlayAttackFX = Net:RemoteEvent("PlayAttackFX"),
		SendNotification = Net:RemoteEvent("SendNotification"),
	}
}

-- UserId ile Rol Kontrolü
function MurdererService:IsMurderer(player)
	local uid = tostring(player.UserId)
	local role = GameService.RunningPlayers[uid]
	return role == "Killer"
end

function MurdererService:_initializeMurdererSkill()
	for userIdStr, role in pairs(GameService.RunningPlayers) do
		if role == "Killer" then
			local player = Players:GetPlayerByUserId(tonumber(userIdStr))

			if player then
				-- 1. ADIM: Her zaman "Attack" (Ana Skill) yükle
				local attackModule = require(MainAttackModule)
				-- İstemciye "Attack" adıyla gönderiyoruz
				self.Network.SkillAssigned:FireClient(player, "Attack", attackModule.Cooldown or 2, attackModule.Keybind)

				-- 2. ADIM: Datadaki Yan Yeteneği (KillerSkill) yükle
				DataService:GetProfile(player):andThen(function(profile)
					-- [GÜNCELLEME] Yeni Data Yapısı: Equippeds.KillerSkill
					local equippedData = profile.Data.Equippeds
					local skillName = ""

					if equippedData and equippedData.KillerSkill then
						skillName = equippedData.KillerSkill
					end

					-- Eğer bir skill seçili değilse veya boşsa işlem yapma
					if skillName ~= "" then
						local skillModuleScript = SecondarySkillsFolder:FindFirstChild(skillName)

						if skillModuleScript then
							local skillModule = require(skillModuleScript)
							local cooldownTime = skillModule.Cooldown or 10
							local keybind = skillModule.Keybind 

							self.Network.SkillAssigned:FireClient(player, skillName, cooldownTime, keybind)
						end
					end
				end)
			end
		end
	end
end

function MurdererService:ActivateSkill(player, skillName, mousePosition)
	if not self:IsMurderer(player) then return end
	if GameService.Gamemode() == "Waiting" then return end
	if typeof(skillName) ~= "string" then return end

	local targetPos = nil
	if mousePosition then
		if typeof(mousePosition) == "CFrame" then
			targetPos = mousePosition.Position
		elseif typeof(mousePosition) == "Vector3" then
			targetPos = mousePosition
		end
	end
	-- Bazı skiller mouse pozisyonu gerektirmeyebilir (örn: kendine hız basma), o yüzden targetPos kontrolünü skill içine bırakmak daha iyi olabilir ama şimdilik senin yapını koruyorum.
	if not targetPos then return end

	local skillModuleScript = nil

	-- [GÜNCELLEME] Skill Seçimi Mantığı
	if skillName == "Attack" then
		-- Eğer gelen istek "Attack" ise direkt ana modülü kullan
		skillModuleScript = MainAttackModule
	else
		-- Değilse, oyuncunun datasındaki yetenek mi diye kontrol et
		local profile = DataService:GetProfile(player):expect() -- Promise beklemesi gerekebilir ama burada direkt erişim varsayıyoruz ya da cache kullanıyordur.
		-- Not: DataService promise döndürüyorsa yukarıdaki gibi :andThen içinde olmalıydı. 
		-- Ancak pratiklik açısından burada mantığı kuruyorum:

		if profile and profile.Data.Equippeds and profile.Data.Equippeds.KillerSkill == skillName then
			skillModuleScript = SecondarySkillsFolder:FindFirstChild(skillName)
		end
	end

	-- Eğer geçerli bir modül bulunamadıysa (Hile koruması: Oyuncu sahip olmadığı veya Attack olmayan bir şey yolladıysa)
	if not skillModuleScript then return end

	-- COOLDOWN KONTROLÜ
	local currentTime = workspace:GetServerTimeNow()
	if not self.Cooldowns[player] then self.Cooldowns[player] = {} end

	local skillAtom = self.Cooldowns[player][skillName]
	if skillAtom and skillAtom() > currentTime then return end

	-- SKILL AKTİVASYONU
	local skillModule = require(skillModuleScript)
	local success = skillModule:Activate(player, GameService, targetPos)

	if success == true then
		local cd = skillModule.Cooldown or 10
		local finish = currentTime + cd

		if not self.Cooldowns[player][skillName] then
			self.Cooldowns[player][skillName] = Charm.atom(finish)
		else
			self.Cooldowns[player][skillName](finish)
		end
		self.Network.CooldownUpdate:FireClient(player, skillName, finish)
	end
end

function MurdererService:OnStart()
	self.Network.ActivateSkill.OnServerEvent:Connect(function(player, skillName, mousePosition)
		self:ActivateSkill(player, skillName, mousePosition)
	end)

	GameService.Signals.GameStarted:Connect(function()
		self:_initializeMurdererSkill()
	end)

	GameService.Signals.GameEnded:Connect(function()
		self.Cooldowns = {}
	end)
end

return MurdererService]]></ProtectedString>
				<string name="ScriptGuid">{E9339E40-B832-4819-B828-65E9982FDB1E}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">MurdererService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX91675DA6082F4D85B5122412A58AD6AD">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	PlayerService.lua
	
	GÜNCELLEME: 
	- Hitbox Sistemi Eklendi: Karakterlerin etrafına 4x6x4 boyutunda görünmez bir kutu oluşturulur.
	  Bu sayede saldırılar (Spherecast/Raycast) karakteri çok daha rahat algılar.
]]

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Shared = ReplicatedStorage:WaitForChild("Shared")
local Services = ServerStorage:WaitForChild("Services")

-- Assets
local Characters = Shared:WaitForChild("Characters")
local OverheadGuiAssets = Shared:WaitForChild("OverheadGuiAssets")

-- Libraries
local Charm = require(Packages:WaitForChild("Charm"))
local FormatKit = require(Packages:WaitForChild("FormatKit"))
local Promise = require(Packages:WaitForChild("Promise"))
local Net = require(Packages:WaitForChild("Net"))

-- Game Services
local DataService = require(Services:WaitForChild("DataService"))
local MonetizationService = require(Services:WaitForChild("MonetizationService"))
local RewardService = require(Services:WaitForChild("RewardService"))

-- Constants
local PlayerIcons = {
	[414410946] = { -- serdar
		"rbxasset://textures/ui/PlayerList/developer.png",
		"rbxassetid://4969357404", 
	},
	[4775564686] = { -- mehmet
		"rbxasset://textures/ui/PlayerList/developer.png",
		"rbxassetid://105540078", 
		"rbxassetid://11104447788"
	},
	[1327643007] = { -- hamza
		"rbxassetid://15423490200", 
		"rbxassetid://10664762623", 
	}
}

-- Service Definition
local PlayerService = {
	Name = script.Name,
	Client = {},

	PlayerChances = {}, 
	KillerPriority = {}, 

	Network = {
		ChanceUpdate = Net:RemoteEvent("ChanceUpdate")
	}
}

--// Client Functions

function PlayerService.Client:GetChance(player)
	return PlayerService:GetChance(player)
end

--// PRIORITY SYSTEM (GARANTİ KATİL)

function PlayerService:SetPriority(player)
	self.KillerPriority[player] = true
end

function PlayerService:HasPriority(player)
	return self.KillerPriority[player] == true
end

function PlayerService:RemovePriority(player)
	self.KillerPriority[player] = nil
end

--// CHANCE SYSTEM

function PlayerService:GetChance(player)
	local atom = self.PlayerChances[player]
	if atom then
		local baseValue = atom()
		if player:GetAttribute("VIP") then
			baseValue = baseValue * 1.5
		end
		return math.floor(baseValue) 
	end
	return 0
end

function PlayerService:ResetChance(player)
	local atom = self.PlayerChances[player]
	if atom then
		atom(0)
		self.Network.ChanceUpdate:FireClient(player, 0)
	end
end

function PlayerService:AddChance(player, amount)
	local atom = self.PlayerChances[player]
	if atom then
		local value = amount or 1
		local newValue = atom() + value
		atom(newValue)
		self.Network.ChanceUpdate:FireClient(player, self:GetChance(player))
	end
end

--// HITBOX SYSTEM (YENİ)
-- Bu fonksiyon her karaktere 4x6x4'lük dev bir hedef kutusu ekler.
function PlayerService:CreateHitbox(character)
	local rootPart = character:WaitForChild("HumanoidRootPart", 5)
	if not rootPart then return end

	-- Zaten varsa tekrar ekleme
	if character:FindFirstChild("Hitbox") then return end

	local hitbox = Instance.new("Part")
	hitbox.Name = "Hitbox"
	hitbox.Size = Vector3.new(4.5, 6, 4.5) -- Karakterden daha geniş bir alan
	hitbox.CFrame = rootPart.CFrame
	hitbox.Transparency = 1 -- Görünmez
	hitbox.CanCollide = false -- İçinden geçilebilir (hareketi engellemez)
	hitbox.CanQuery = true -- Raycast/Spherecast buna çarpabilir! (ÖNEMLİ)
	hitbox.CanTouch = true 
	hitbox.Massless = true -- Ağırlık yapmaz
	hitbox.Parent = character

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = rootPart
	weld.Part1 = hitbox
	weld.Parent = hitbox
end

--// SPAWNER SYSTEM

function PlayerService:SpawnSurvivors(runningPlayers, spawnLocations)
	for player, role in pairs(runningPlayers) do
		if role == "Survivor" then
			self:_spawnPlayer(player, spawnLocations, "Survivor")
		end
	end
end

function PlayerService:SpawnKillers(runningPlayers, spawnLocations)
	for player, role in pairs(runningPlayers) do
		if role == "Killer" then
			self:_spawnPlayer(player, spawnLocations, "Killer")
		end
	end
end

function PlayerService:DespawnAll()
	for _, player in ipairs(Players:GetPlayers()) do
		player.RespawnLocation = nil
		player:LoadCharacterAsync()
		player:SetAttribute("Role", nil)
	end
end

function PlayerService:_spawnPlayer(player, spawnLocations, role)
	if not player then return end
	player:SetAttribute("Role", role)

	DataService:GetProfile(player):andThen(function(profile)
		-- Spawn noktası belirleme
		local randomSpawn = nil
		if spawnLocations and #spawnLocations > 0 then
			randomSpawn = spawnLocations[math.random(1, #spawnLocations)]
			player.RespawnLocation = randomSpawn
		end

		-- Spawn CFrame hesaplama
		local spawnCFrame = randomSpawn and (randomSpawn.CFrame * CFrame.new(0, 3, 0)) or CFrame.new(0, 10, 0)

		-- EĞER OYUNCU KATİL İSE
		if role == "Killer" then
			local equippedSkin = profile.Data.Equippeds and profile.Data.Equippeds.KillerSkin
			local characterModel = nil
			if equippedSkin then 
				characterModel = Characters:FindFirstChild(equippedSkin) 
			end

			if not characterModel then 
				characterModel = Characters:FindFirstChild("Bloxxer") 
			end

			if characterModel then
				local newCharacter = characterModel:Clone()
				newCharacter.Name = player.Name
				newCharacter:PivotTo(spawnCFrame)
				newCharacter.Parent = workspace
				player.Character = newCharacter

				-- [YENİ] Hitbox Ekle
				self:CreateHitbox(newCharacter)

				Net:RemoteEvent("StartFX"):FireAllClients("KillerSpawn", player)

				local rootPart = newCharacter:FindFirstChild("HumanoidRootPart")
				if rootPart then
					rootPart:SetNetworkOwner(player)
				end

				return 
			else
				warn("HATA: Bloxxer/Skin modeli bulunamadı!")
			end
		end

		-- EĞER OYUNCU SURVIVOR İSE
		local connection
		connection = player.CharacterAdded:Connect(function(character)
			local rootPart = character:WaitForChild("HumanoidRootPart", 5)
			if rootPart then
				character:PivotTo(spawnCFrame)
				-- [YENİ] Hitbox Ekle
				self:CreateHitbox(character)
			end
			if connection then connection:Disconnect() end
		end)

		player:LoadCharacterAsync()

	end):catch(function(err)
		warn("Spawn hatası:", err)
		player:LoadCharacterAsync()
	end)
end

--// INITIALIZATION

function PlayerService:OnStart()

	-- 1. Monetization Kaydı
	MonetizationService:Register(MonetizationService.Type.Product, 3530798250, function(Player : Player)
		self:SetPriority(Player)
		Net:RemoteEvent("SendNotification", "You will be next killer this round", 10)
		return true
	end)

	MonetizationService:Register(MonetizationService.Type.Gamepass, 1705481042, function(Player : Player)
		DataService:GetProfile(Player):andThen(function(Profile)
			Profile.Data.KillerSkins["Rich"] = true
		end)
		RewardService:AddCurrency(Player, 2000, "VIP")
		Player:SetAttribute("VIP", true)
	end)

	-- 2. DataService Sinyalini Dinle
	DataService.Signals.DataUpdate:Connect(function(player, path, newValue)
		if not player then return end

		-- A. Leaderstats Güncellemesi
		local leaderstats = player:FindFirstChild("leaderstats")
		if leaderstats then
			if path == "CurrencyData.Value" then
				local tokenVal = leaderstats:FindFirstChild("Tokens")
				if tokenVal then tokenVal.Value = newValue end
			elseif path == "LevelData.Level" then
				local levelVal = leaderstats:FindFirstChild("Level")
				if levelVal then levelVal.Value = newValue end
			end
		end

		-- B. OverheadGui Güncellemesi
		if string.find(path, "LevelData") then
			local character = player.Character
			if character then
				local overhead = character:FindFirstChild("OverheadGui", true)
				if overhead then
					local fullData = DataService:GetData(player)
					if fullData then
						overhead.Level.Value.Text = `Level {FormatKit.FormatComma(fullData.LevelData.Level)}`
						local ratio = math.clamp(fullData.LevelData.ValueXP / fullData.LevelData.TargetXP, 0, 1)
						overhead.Level.FillBar.Size = UDim2.new(ratio, 0, 1, 0)
					end
				end
			end
		end
	end)

	-- 3. Oyuncu Katıldığında
	Players.PlayerAdded:Connect(function(player)
		player:SetAttribute("VIP", MonetizationService:UserHas(player, 1705481042)) 

		-- A. Leaderstats
		local Data = DataService:GetData(player)
		local Leaderstats = Instance.new("Folder")
		Leaderstats.Name = "leaderstats"
		Leaderstats.Parent = player

		local Tokens = Instance.new("IntValue")
		Tokens.Name = "Tokens"
		Tokens.Value = Data.CurrencyData.Value
		Tokens.Parent = Leaderstats

		local Level = Instance.new("IntValue")
		Level.Name = "Level"
		Level.Value = Data.LevelData.Level
		Level.Parent = Leaderstats

		-- B. Karakter Yüklendiğinde (Overhead Gui + Hitbox)
		local function CharacterAdded(Character : Model)
			-- [YENİ] Lobi veya normal spawn fark etmeksizin Hitbox ekle
			self:CreateHitbox(Character)

			if (not player:GetAttribute("Role")) then
				local OverheadGui = OverheadGuiAssets.OverheadGui:Clone()
				OverheadGui.Parent = Character.PrimaryPart or Character
				OverheadGui.Display.Username.Text = player.DisplayName

				if (player.UserId <= 0) then
					local Icon = OverheadGuiAssets.Icon:Clone()
					Icon.Image = "rbxasset://textures/ui/PlayerList/developer.png"
					Icon.Parent = OverheadGui.Display
				end

				if (player.MembershipType ~= Enum.MembershipType.None) then
					local PremiumIcon = OverheadGuiAssets.Icon:Clone()
					PremiumIcon.Image = "rbxasset://textures/ui/PlayerList/PremiumIcon.png"
					PremiumIcon.Parent = OverheadGui.Display
				end

				local IconTable = PlayerIcons[player.UserId] or {}
				for _,IconId in ipairs(IconTable) do
					local Icon = OverheadGuiAssets.Icon:Clone()
					Icon.Image = IconId
					Icon.Parent = OverheadGui.Display
				end

				OverheadGui.Level.Value.Text = `Level {FormatKit.FormatComma(Data.LevelData.Level)}`
				local ratio = math.clamp(Data.LevelData.ValueXP / Data.LevelData.TargetXP, 0, 1)
				OverheadGui.Level.FillBar.Size = UDim2.new(ratio, 0, 1, 0)
			end

			for _,Basepart in ipairs(Character:GetDescendants()) do
				if (Basepart:IsA("BasePart") and Basepart.Name ~= "Hitbox") then -- Hitbox'ı collision grubuna alma
					Basepart.CollisionGroup = "Player"
				end
			end
		end

		if (player.Character) then 
			CharacterAdded(player.Character) 
		end
		player.CharacterAdded:Connect(CharacterAdded)

		self.PlayerChances[player] = Charm.atom(math.random(4,8))
		self.Network.ChanceUpdate:FireClient(player, self.PlayerChances[player]())
	end)

	-- 4. Oyuncu Ayrıldığında
	Players.PlayerRemoving:Connect(function(player)
		self.PlayerChances[player] = nil
		self.KillerPriority[player] = nil 
	end)

	-- 5. Mevcut Oyuncular İçin Şans Başlatma
	for _, player in ipairs(Players:GetPlayers()) do
		if not self.PlayerChances[player] then
			self.PlayerChances[player] = Charm.atom(0)
		end
	end
end

return PlayerService]]></ProtectedString>
				<string name="ScriptGuid">{67893CAD-3B35-493F-AB9E-EA85AB722B92}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">PlayerService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX6FF018EB3AE2403285C82AF562274CAD">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
    GameService.lua - BULLETPROOF VERSION (FIXED VOTING BUG)
    
    GÜNCELLEMELER:
    1. Fix: Oylama sırasında oyuncu çıkarsa ekranın takılı kalması sorunu çözüldü (ResetMatch içine Force Clear eklendi).
    2. Fix: OnStart döngüsünde hata anında önce Reset atılıyor, sonra bekleniyor (Anlık UI temizliği).
    3. Genel: Kod yapısı korundu, gereksiz tablolar kaldırıldı.
]]

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")
local AnalyticsService = game:GetService("AnalyticsService") -- Ham API

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Services = ServerStorage:WaitForChild("Services")
local Modules = ServerStorage:WaitForChild("Modules")
local GameModesFolder = Modules:WaitForChild("GameModes")
local Shared = ReplicatedStorage:WaitForChild("Shared")

local WaitingRoom = Shared:WaitForChild("WaitingRoom") -- WaitingRoom modeli burada olmalı

-- Dependencies
local Promise = require(Packages:WaitForChild("Promise"))
local Signal = require(Packages:WaitForChild("Signal"))
local Charm = require(Packages:WaitForChild("Charm"))
local Net = require(Packages:WaitForChild("Net"))

-- Service Dependencies
local DataService = require(Services:WaitForChild("DataService")) 
local PlayerService = require(Services:WaitForChild("PlayerService"))
local MapService = require(Services:WaitForChild("MapService"))
local RewardService = require(Services:WaitForChild("RewardService"))

-- Constants
local CONFIG = {
	VOTING_TIME = 15,
	WARMUP_TIME = 10,
	GAME_TIME = 90,
	INTERMISSION = 5,
	MIN_PLAYERS = 2,
	RESULT_SCREEN_TIME = 10,
	MAX_MAP_LOAD_RETRIES = 3
}

-- Module Definition
local GameService = {
	Name = script.Name,
	Client = {},

	-- Global State
	Gamemode = Charm.atom("Waiting"),
	TimeLeft = Charm.atom(0), 
	GameStatus = Charm.atom("Intermission"), 
	SurvivorCount = Charm.atom(0),

	-- Admin & Voting State
	NextMapOverride = Charm.atom(nil),
	CurrentOptions = Charm.atom({}), 
	Votes = Charm.atom({}),             

	-- Internal Game State
	RunningPlayers = {}, 
	RoundStartSnapshots = {},
	_connections = {}, 
	_gameLoopTask = nil,
	_activeModeModule = nil,
	_activeWaitingRoom = nil,
	_isGameActive = false,
	_votingCancelled = false,       
	_loadingCancelled = false,    

	-- Analytics State
	CurrentMapName = "Unknown",
	GameStartTime = 0,

	Signals = {
		GameEnded = Signal.new(),
		WarmupStarted = Signal.new(), 
		GameStarted = Signal.new(),     
	},

	Network = {
		StateUpdate = Net:RemoteEvent("StateUpdate"),
		VoteOptions = Net:RemoteEvent("VoteOptions"), 
		VoteUpdate = Net:RemoteEvent("VoteUpdate"),         
		WarmupStarted = Net:RemoteEvent("WarmupStarted"),
		GameStarted = Net:RemoteEvent("GameStarted"),
		GameEnded = Net:RemoteEvent("GameEnded"),
		CastVote = Net:RemoteEvent("CastVote"),
		LoadLighting = Net:RemoteEvent("LoadLighting"),
		Results = Net:RemoteEvent("Results"),
		StartFX = Net:RemoteEvent("StartFX")
	}
}

GameService.Client.Server = GameService

---

-- =============================================================================
--  CLIENT API
-- =============================================================================

function GameService.Client:GetPlayersStatus(player)
	local playerStatusList = {}
	for _, targetPlayer in ipairs(Players:GetPlayers()) do
		local userIdString = tostring(targetPlayer.UserId)
		local currentRole = self.Server.RunningPlayers[userIdString] or "Lobby"
		playerStatusList[targetPlayer.Name] = currentRole
	end
	return playerStatusList
end

function GameService.Client:GetPlayerData(player, targetPlayerName: string)
	local targetPlayer = Players:FindFirstChild(targetPlayerName)
	if not targetPlayer then return nil end

	local targetIdString = tostring(targetPlayer.UserId)
	local role = self.Server.RunningPlayers[targetIdString] or "Lobby"

	return {
		PlayerName = targetPlayer.Name,
		Role = role,
		UserId = targetPlayer.UserId,
		IsAlive = (targetPlayer.Character and targetPlayer.Character:FindFirstChild("Humanoid") and targetPlayer.Character.Humanoid.Health > 0) or false
	}
end

function GameService.Client:GetGameState()
	return Charm.peek(GameService.GameStatus())
end

---

-- =============================================================================
--  HELPER FUNCTIONS
-- =============================================================================

local function LogMetric(player, eventName, value)
	local safeValue = tonumber(value) or 1
	pcall(function()
		AnalyticsService:LogCustomEvent(player, eventName, safeValue)
	end)
end

function GameService:_getValidPlayers()
	local valid = {}
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Parent then 
			table.insert(valid, player)
		end
	end
	return valid
end

function GameService:_calculateVoteCounts()
	local options = self.CurrentOptions()
	local currentVotes = self.Votes()
	local voteCounts = {}

	for _, optionData in ipairs(options) do 
		voteCounts[optionData.Id] = 0 
	end

	for userId, mapId in pairs(currentVotes) do
		if voteCounts[mapId] ~= nil then 
			local voteWeight = 1
			local player = Players:GetPlayerByUserId(userId)
			if player and player:GetAttribute("VIP") then
				voteWeight = 2
			end
			voteCounts[mapId] = voteCounts[mapId] + voteWeight 
		end
	end
	return voteCounts
end

function GameService:_countSurvivors()
	local count = 0
	for _, role in pairs(self.RunningPlayers) do
		if role == "Survivor" then 
			count = count + 1 
		end
	end
	return count
end

function GameService:_countKillers()
	local count = 0
	for _, role in pairs(self.RunningPlayers) do
		if role == "Killer" then 
			count = count + 1 
		end
	end
	return count
end

function GameService:SelectWeightedKiller(playerCandidates)
	local priorityList = {}
	for _, player in ipairs(playerCandidates) do
		if PlayerService:HasPriority(player) then
			table.insert(priorityList, player)
		end
	end

	if #priorityList > 0 then
		local winnerPlayer = priorityList[math.random(1, #priorityList)]
		PlayerService:RemovePriority(winnerPlayer)
		return winnerPlayer
	end

	local totalChance = 0
	local selectionPool = {}

	for _, player in ipairs(playerCandidates) do
		local chance = PlayerService:GetChance(player)
		if chance <= 0 then chance = 1 end
		totalChance = totalChance + chance
		table.insert(selectionPool, {Player = player, Weight = totalChance})
	end

	local randomNumber = math.random(1, totalChance)
	for _, poolEntry in ipairs(selectionPool) do
		if randomNumber <= poolEntry.Weight then
			return poolEntry.Player
		end
	end
	return playerCandidates[1]
end

function GameService:SetNextMap(mapName)
	local mapModule = MapService:FindMapModule(mapName)
	if mapModule then
		self.NextMapOverride(mapModule)
		return true
	end
	return false
end

function GameService:CastVote(player, mapId)
	if self.GameStatus() ~= "OnVoting" then return end
	if self._votingCancelled then return end

	local isValid = false
	for _, option in ipairs(self.CurrentOptions()) do 
		if option.Id == mapId then 
			isValid = true 
			break 
		end 
	end

	if not isValid then return end

	self.Votes(function(currentVotes) 
		local newVotes = table.clone(currentVotes) 
		newVotes[player.UserId] = mapId 
		return newVotes 
	end)
end

function GameService:_spawnWaitingRoom()
	if self._activeWaitingRoom then return end

	if WaitingRoom then
		self._activeWaitingRoom = WaitingRoom:Clone()
		self._activeWaitingRoom.Parent = workspace

		if not self._activeWaitingRoom.PrimaryPart then
			warn("UYARI: WaitingRoom modelinin PrimaryPart'ı ayarlı değil! Işınlanma hatalı olabilir.")
		end
	else
		warn("KRİTİK HATA: Shared/WaitingRoom bulunamadı!")
	end
end

function GameService:ResetMatch()
	-- State Reset
	self.GameStatus("Intermission")
	self.Gamemode("Waiting")
	self._activeModeModule = nil
	self.RunningPlayers = {}
	self.RoundStartSnapshots = {}
	self.Votes({})
	self.CurrentOptions({})
	self.NextMapOverride(nil)
	self.SurvivorCount(0)

	-- [CRITICAL FIX] Client'taki Oylama Ekranını Zorla Kapat
	-- Boş seçenek ve 0 süre göndererek Client UI'ın kapanmasını garanti ediyoruz.
	pcall(function()
		self.Network.VoteOptions:FireAllClients({}, 0)
		self.Network.StateUpdate:FireAllClients("TimeLeft", 0)
	end)

	-- Analytics Reset
	self.CurrentMapName = "Unknown"
	self.GameStartTime = 0

	-- Flags Reset
	self._isGameActive = false
	self._votingCancelled = false
	self._loadingCancelled = false

	if self._gameLoopTask then 
		task.cancel(self._gameLoopTask) 
		self._gameLoopTask = nil 
	end

	-- WaitingRoom Temizliği
	if self._activeWaitingRoom then
		self._activeWaitingRoom:Destroy()
		self._activeWaitingRoom = nil
	end

	MapService:Cleanup()
	PlayerService:DespawnAll()
end

-- =============================================================================
--  GAME PHASES
-- =============================================================================

function GameService:RunVotingPhase()
	self.GameStatus("OnVoting")
	self.TimeLeft(CONFIG.VOTING_TIME)
	self._votingCancelled = false

	local processedOptions = MapService:GetProcessedVoteOptions(3)
	self.CurrentOptions(processedOptions)
	self.Votes({})

	self.Network.VoteOptions:FireAllClients(processedOptions, CONFIG.VOTING_TIME)

	for currentTime = CONFIG.VOTING_TIME, 1, -1 do
		-- Her saniye iptal durumunu kontrol et
		if self._votingCancelled then return nil end
		if #Players:GetPlayers() < CONFIG.MIN_PLAYERS then 
			warn("Voting cancelled: Not enough players")
			self._votingCancelled = true
			return nil 
		end

		self.TimeLeft(currentTime)
		task.wait(1)
	end

	-- Son bir kontrol
	if self._votingCancelled or #Players:GetPlayers() < CONFIG.MIN_PLAYERS then 
		self._votingCancelled = true
		return nil 
	end

	local voteCounts = self:_calculateVoteCounts()
	local maxVotes, candidates = -1, {}

	for mapId, count in pairs(voteCounts) do
		if count > maxVotes then 
			maxVotes = count 
			candidates = {mapId} 
		elseif count == maxVotes then 
			table.insert(candidates, mapId) 
		end
	end

	local winnerId = candidates[math.random(1, #candidates)]
	local winnerModule = MapService:FindMapModule(winnerId)

	if not winnerModule and #processedOptions > 0 then 
		winnerModule = MapService:FindMapModule(processedOptions[1].Id) 
	end

	return winnerModule
end

function GameService:_loadMapSafely(mapModule)
	local retries = 0
	local mapData = nil

	while retries < CONFIG.MAX_MAP_LOAD_RETRIES do
		local success, result = pcall(function() 
			return MapService:LoadMap(mapModule) 
		end)

		if success and result then
			mapData = result
			break
		else
			retries = retries + 1
			warn(string.format("Map load retry %d/%d", retries, CONFIG.MAX_MAP_LOAD_RETRIES))

			if retries < CONFIG.MAX_MAP_LOAD_RETRIES then
				pcall(function() 
					MapService:Cleanup() 
				end)
				task.wait(1)
			end
		end
	end

	if not mapData then warn("Failed to load map") end
	return mapData
end

-- =============================================================================
--  START GAME
-- =============================================================================

function GameService:StartGame()
	if self._isGameActive then return Promise.reject("Game already active") end

	local activePlayers = self:_getValidPlayers()
	if #activePlayers < CONFIG.MIN_PLAYERS then return Promise.reject("Yetersiz Oyuncu (Start)") end

	self._isGameActive = true
	self._loadingCancelled = false

	-- WaitingRoom Oluştur
	self:_spawnWaitingRoom()

	-- 1. Voting
	local mapModule = self.NextMapOverride() or self:RunVotingPhase()
	self.NextMapOverride(nil)

	if self._votingCancelled or not mapModule then 
		self._isGameActive = false
		return Promise.reject("Voting Cancelled") 
	end

	self.CurrentMapName = tostring(mapModule.Name) 
	self.GameStatus("Loading")

	-- 2. Data Loading
	local dataPromises = {}
	activePlayers = self:_getValidPlayers()
	for _, player in ipairs(activePlayers) do 
		table.insert(dataPromises, DataService:GetProfile(player)) 
	end

	return Promise.all(dataPromises):andThen(function()

		-- [CHECKPOINT 1] Data Yükleme Kontrolü
		if not self._isGameActive or self._loadingCancelled or #Players:GetPlayers() < CONFIG.MIN_PLAYERS then
			error("Loading Aborted: State Invalid after Data Load")
		end

		self.RoundStartSnapshots = {}
		activePlayers = self:_getValidPlayers()
		for _, player in ipairs(activePlayers) do
			self.RoundStartSnapshots[player] = self:_getPlayerDataSnapshot(player)
		end

		-- 3. Map Loading
		local mapData = self:_loadMapSafely(mapModule)
		if not mapData then error("Map Load Failed") end

		-- [CHECKPOINT 2] Harita Yükleme Kontrolü
		if not self._isGameActive or self._loadingCancelled or #Players:GetPlayers() < CONFIG.MIN_PLAYERS then
			error("Loading Aborted: State Invalid after Map Load")
		end

		if mapData.Lighting then 
			pcall(function() 
				self.Network.LoadLighting:FireAllClients(mapData.Lighting) 
			end)
		end

		-- 4. Mode Setup
		self:_setupGameMode(activePlayers)

		-- [CHECKPOINT 3] Setup Kontrolü
		if not self._isGameActive then error("Game cancelled during setup") end

		-- KILLER'I WAITING ROOM'A IŞINLA
		if self._activeWaitingRoom and self._activeWaitingRoom.PrimaryPart then
			for userIdString, role in pairs(self.RunningPlayers) do
				if role == "Killer" then
					local killerPlayer = Players:GetPlayerByUserId(tonumber(userIdString))
					if killerPlayer and killerPlayer.Character then
						task.wait(0.1)
						killerPlayer.Character:PivotTo(self._activeWaitingRoom:GetPivot())
					end
				end
			end
		end

		local currentSurvivorCount = 0
		for _, role in pairs(self.RunningPlayers) do 
			if role == "Survivor" then 
				currentSurvivorCount = currentSurvivorCount + 1 
			end 
		end
		self.SurvivorCount(currentSurvivorCount)

		-- 5. Warmup
		self.GameStatus("Warmup")
		self.TimeLeft(CONFIG.WARMUP_TIME)

		self.Network.WarmupStarted:FireAllClients(self.Gamemode(), self.RunningPlayers, CONFIG.WARMUP_TIME)
		self.Signals.WarmupStarted:Fire()

		local activeInstancesRoles = {}
		for userIdString, role in pairs(self.RunningPlayers) do
			local player = Players:GetPlayerByUserId(tonumber(userIdString))
			if player and player.Parent then 
				activeInstancesRoles[player] = role 
			else 
				self.RunningPlayers[userIdString] = nil 
			end
		end

		-- Sadece Survivorları haritaya spawn et
		PlayerService:SpawnSurvivors(activeInstancesRoles, mapData.Spawns)
		self:_setupPlayerMonitoring()

		-- Warmup Döngüsü
		for currentTime = CONFIG.WARMUP_TIME, 1, -1 do
			if not self._isGameActive then 
				warn("StartGame Aborted: Game ended externally during Warmup")
				return 
			end

			if #Players:GetPlayers() < CONFIG.MIN_PLAYERS then 
				self:EndGame(nil) 
				return 
			end

			self.TimeLeft(currentTime)
			task.wait(1)
		end

		-- [CHECKPOINT 4] Son Kontrol
		if not self._isGameActive then 
			warn("StartGame Aborted: Game ended right before start")
			return 
		end

		self.GameStatus("GameRunning")
		self.GameStartTime = os.time()

		-- 6. Killer Spawn & Game Loop
		local currentPlayersForSpawn = {}
		for userIdString, role in pairs(self.RunningPlayers) do
			local player = Players:GetPlayerByUserId(tonumber(userIdString))
			if player and player.Parent then 
				currentPlayersForSpawn[player] = role 
			end
		end

		PlayerService:SpawnKillers(currentPlayersForSpawn, mapData.Spawns)

		local modeDuration = (self._activeModeModule and self._activeModeModule.Time) or CONFIG.GAME_TIME
		self.Network.GameStarted:FireAllClients(modeDuration)
		self.Network.StateUpdate:FireAllClients("TimeLeft", modeDuration) 
		self.Signals.GameStarted:Fire()

		self:_startTimeLoop()

	end):catch(function(err)
		warn("StartGame Error/Abort:", err)
		self._isGameActive = false
		self._loadingCancelled = false
		self:ResetMatch()
	end)
end

function GameService:_setupGameMode(players)
	local connectedPlayers = {}
	for _, player in ipairs(players) do
		if player and player.Parent then 
			table.insert(connectedPlayers, player) 
		end
	end

	if #connectedPlayers < CONFIG.MIN_PLAYERS then 
		error("Not enough players for mode setup") 
	end

	local modes = GameModesFolder:GetChildren()
	local selectedScript = modes[math.random(1, #modes)]
	local modeModule = require(selectedScript)

	if modeModule.MinPlayers and #connectedPlayers < modeModule.MinPlayers then
		modeModule = require(GameModesFolder.Classic)
		selectedScript = GameModesFolder.Classic
	end

	self._activeModeModule = modeModule
	self.Gamemode(selectedScript.Name)

	local rawRoles = modeModule:Start(self, connectedPlayers)
	self.RunningPlayers = {} 

	for playerInstance, roleName in pairs(rawRoles) do
		if playerInstance and playerInstance:IsA("Player") and playerInstance.Parent then
			local userIdString = tostring(playerInstance.UserId)
			self.RunningPlayers[userIdString] = roleName

			if roleName == "Killer" then 
				PlayerService:ResetChance(playerInstance)
			else 
				PlayerService:AddChance(playerInstance, 1) 
			end
		end
	end
end

function GameService:_setupPlayerMonitoring()
	for userIdString, role in pairs(self.RunningPlayers) do
		local userId = tonumber(userIdString)
		local player = Players:GetPlayerByUserId(userId)

		if player and player.Parent then
			local function monitorCharacter(character)
				local humanoid = character:WaitForChild("Humanoid", 10)
				if not humanoid then return end

				local connection = humanoid.Died:Connect(function()
					if not self._isGameActive then return end
					if self.GameStatus() ~= "GameRunning" and self.GameStatus() ~= "Warmup" then return end

					if self._activeModeModule and self._activeModeModule.OnPlayerDied then
						pcall(function() 
							self._activeModeModule:OnPlayerDied(self, player) 
						end)
					end

					if role == "Survivor" then
						local newTime = self.TimeLeft() + 7
						self.TimeLeft(newTime)
						self.Network.StateUpdate:FireAllClients("TimeLeft", newTime)

						self.RunningPlayers[userIdString] = nil 
						self.SurvivorCount(self:_countSurvivors())

						task.delay(3, function()
							if self._isGameActive and player and player.Parent then 
								pcall(function() 
									player:LoadCharacterAsync() 
								end)
							end
						end)

						if self:_countSurvivors() <= 0 then
							self:EndGame("Killer")
						end

					elseif role == "Killer" then
						self:EndGame("Survivors")
					end
				end)
				table.insert(self._connections, connection)
			end

			if player.Character then 
				pcall(function() 
					monitorCharacter(player.Character) 
				end) 
			end

			local conn = player.CharacterAdded:Connect(function(char) 
				pcall(function() 
					monitorCharacter(char) 
				end) 
			end)
			table.insert(self._connections, conn)
		end
	end
end

function GameService:_startTimeLoop()
	if self._gameLoopTask then task.cancel(self._gameLoopTask) end

	local modeDuration = (self._activeModeModule and self._activeModeModule.Time) or CONFIG.GAME_TIME
	self.TimeLeft(modeDuration)

	self._gameLoopTask = task.spawn(function()
		while self.TimeLeft() > 0 do
			task.wait(1)

			if not self._isGameActive then break end

			self.TimeLeft(self.TimeLeft() - 1)

			if self._activeModeModule and self._activeModeModule.CheckWinCondition then
				local success, winner = pcall(function() 
					return self._activeModeModule:CheckWinCondition(self) 
				end)

				if success and winner then 
					self:EndGame(winner) 
					return
				end
			end
		end

		if self._isGameActive and self.TimeLeft() <= 0 then
			-- Time Out: Survivors Win
			for userIdString, role in pairs(self.RunningPlayers) do
				if role == "Killer" then
					local player = Players:GetPlayerByUserId(tonumber(userIdString))
					if player and player.Parent and player.Character then
						local h = player.Character:FindFirstChild("Humanoid")
						if h then 
							pcall(function() h.Health = 0 end) 
						end
					end
				end
			end

			task.wait(1) 

			if self.GameStatus() == "GameRunning" then
				self:EndGame("Survivors")
			end
		end
	end)
end

function GameService:_getPlayerDataSnapshot(player)
	if not player or not player.Parent then return {Token = 0, XP = 0, Level = 1, TargetXP = 100} end

	local success, data = pcall(function() 
		return DataService:GetData(player) 
	end)

	if success and data then
		return {
			Token = data.CurrencyData.Value, 
			XP = data.LevelData.ValueXP,
			Level = data.LevelData.Level, 
			TargetXP = data.LevelData.TargetXP
		}
	end
	return {Token = 0, XP = 0, Level = 1, TargetXP = 100}
end

function GameService:_calculateEarnings(startData, endData)
	if not startData or not endData then return {Token = 0, XP = 0} end

	local earnedToken = math.max(0, endData.Token - startData.Token)
	local earnedXP = 0

	if endData.Level == startData.Level then 
		earnedXP = math.max(0, endData.XP - startData.XP)
	else
		local levelDiff = endData.Level - startData.Level
		earnedXP = (levelDiff * startData.TargetXP) + (endData.XP - startData.XP) 
	end

	return {Token = earnedToken, XP = math.max(0, earnedXP)}
end

-- =============================================================================
--  END GAME LOGIC
-- =============================================================================

function GameService:EndGame(winningTeam)
	if not self._isGameActive then
		warn("EndGame ignored: Game already ended")
		return
	end

	local matchDuration = math.max(0, os.time() - self.GameStartTime)
	local endReason = "Unknown"

	if winningTeam == "Killer" then 
		endReason = "AllSurvivorsDead"
	elseif winningTeam == "Survivors" then
		if self.TimeLeft() <= 0 then 
			endReason = "TimeLimit" 
		else 
			endReason = "KillerDeath" 
		end
	else 
		endReason = "ForcedEnd" 
	end

	local mapName = tostring(self.CurrentMapName or "Unknown")

	for userIdString, role in pairs(self.RunningPlayers) do
		local player = Players:GetPlayerByUserId(tonumber(userIdString))
		if player then
			local isWin = false
			if winningTeam == "Killer" and role == "Killer" then isWin = true end
			if winningTeam == "Survivors" and role == "Survivor" then isWin = true end

			LogMetric(player, "Match_Duration", matchDuration)
			LogMetric(player, "Match_Map_" .. mapName, 1)
			LogMetric(player, "Match_Result_" .. role .. "_" .. (isWin and "Win" or "Loss"), 1)
			LogMetric(player, "Match_EndReason_" .. endReason, 1)
		end
	end

	self._isGameActive = false 

	if self._gameLoopTask then 
		task.cancel(self._gameLoopTask) 
		self._gameLoopTask = nil 
	end

	for _, connection in ipairs(self._connections) do 
		pcall(function() 
			connection:Disconnect() 
		end) 
	end
	self._connections = {}

	-- REWARDS
	for userIdString, role in pairs(self.RunningPlayers) do
		local player = Players:GetPlayerByUserId(tonumber(userIdString))
		if player and player.Parent then
			pcall(function()
				if winningTeam == "Killer" and role == "Killer" then
					RewardService:AddXP(player, 100)
					RewardService:AddCurrency(player, 50, "MatchWin_Killer")
				elseif winningTeam == "Survivors" and role == "Survivor" then
					RewardService:AddXP(player, 25)
					RewardService:AddCurrency(player, 25, "MatchWin_Survivor")
				else
					RewardService:AddXP(player, 10)
					RewardService:AddCurrency(player, 5, "MatchParticipation")
				end
			end)
		end
	end

	local resultsPayload = {
		Winner = winningTeam,
		KillerName = "None",
		KillerId = 0,
		KillerSkin = "Wendigo",
		Survivors = {}, 
	}

	for userIdString, role in pairs(self.RunningPlayers) do
		if role == "Killer" then
			local killerPlayer = Players:GetPlayerByUserId(tonumber(userIdString))
			if killerPlayer and killerPlayer.Parent then
				resultsPayload.KillerName = killerPlayer.Name
				resultsPayload.KillerId = killerPlayer.UserId
				pcall(function()
					local profile = DataService.LoadedProfiles[killerPlayer]
					if profile and profile.Data.Equippeds.KillerSkin then
						resultsPayload.KillerSkin = profile.Data.Equippeds.KillerSkin
					end
				end)
			else 
				resultsPayload.KillerName = "Disconnected" 
			end
			break 
		end
	end

	for _, player in ipairs(Players:GetPlayers()) do
		if player and player.Parent then
			local uidString = tostring(player.UserId)
			local role = self.RunningPlayers[uidString]
			local isDead = (role == nil)

			if uidString ~= tostring(resultsPayload.KillerId) then
				table.insert(resultsPayload.Survivors, { 
					Name = player.Name, 
					UserId = player.UserId, 
					IsDead = isDead 
				})
			end
		end
	end

	for _, player in ipairs(Players:GetPlayers()) do
		if player and player.Parent then
			pcall(function()
				local startData = self.RoundStartSnapshots[player] or {Token = 0, XP = 0, Level = 1, TargetXP = 100}
				local endData = self:_getPlayerDataSnapshot(player)
				local earned = self:_calculateEarnings(startData, endData)

				local personalizedData = table.clone(resultsPayload)
				personalizedData.MyRewards = earned

				self.Network.Results:FireClient(player, personalizedData)
			end)
		end
	end

	self.TimeLeft(0)
	self.Network.StateUpdate:FireAllClients("TimeLeft", 0)

	if winningTeam == "Killer" then 
		self.GameStatus("MurdererWin")
	elseif winningTeam == "Survivors" then 
		self.GameStatus("SurvivorsWin")
	else 
		self.GameStatus("Intermission") 
	end

	self.Network.GameEnded:FireAllClients()
	self.Signals.GameEnded:Fire()
end

-- =============================================================================
--  INITIALIZATION
-- =============================================================================

function GameService:OnStart()
	local function sync(name, atom)
		Charm.effect(function() 
			pcall(function() 
				self.Network.StateUpdate:FireAllClients(name, atom()) 
			end) 
		end)
	end

	sync("Gamemode", self.Gamemode)
	sync("GameStatus", self.GameStatus)
	sync("SurvivorCount", self.SurvivorCount)

	Charm.effect(function() 
		pcall(function() 
			self.Network.VoteUpdate:FireAllClients(self:_calculateVoteCounts()) 
		end) 
	end)

	Players.PlayerRemoving:Connect(function(player)
		local userIdString = tostring(player.UserId)
		local playerCount = #Players:GetPlayers()

		if self.GameStatus() == "OnVoting" and playerCount < CONFIG.MIN_PLAYERS then 
			self._votingCancelled = true 
		end

		if self.GameStatus() == "Loading" and playerCount < CONFIG.MIN_PLAYERS then 
			self._loadingCancelled = true 
		end

		if self.RunningPlayers[userIdString] then 
			local role = self.RunningPlayers[userIdString]

			if self.GameStatus() == "GameRunning" and self._isGameActive then
				local timePlayed = math.max(0, os.time() - self.GameStartTime)
				local mapName = tostring(self.CurrentMapName or "Unknown")

				LogMetric(player, "Player_Dropout_" .. role, timePlayed)
				LogMetric(player, "Player_Dropout_Map_" .. mapName, 1)
			end

			self.RunningPlayers[userIdString] = nil

			if self.GameStatus() == "GameRunning" or self.GameStatus() == "Warmup" then
				if role == "Survivor" then
					self.SurvivorCount(self:_countSurvivors())
					if self:_countSurvivors() <= 0 then 
						self:EndGame("Killer") 
					end
				elseif role == "Killer" then
					if self:_countKillers() <= 0 then 
						self:EndGame("Survivors") 
					end
				end
			end
		end
	end)

	self.Network.CastVote.OnServerEvent:Connect(function(player, mapId) 
		pcall(function() 
			self:CastVote(player, mapId) 
		end) 
	end)

	Players.PlayerAdded:Connect(function(player)
		pcall(function()
			self.Network.StateUpdate:FireClient(player, "Gamemode", self.Gamemode())
			self.Network.StateUpdate:FireClient(player, "GameStatus", self.GameStatus())
			self.Network.StateUpdate:FireClient(player, "SurvivorCount", self.SurvivorCount())
			self.Network.StateUpdate:FireClient(player, "TimeLeft", self.TimeLeft())

			if self.GameStatus() == "OnVoting" and #self.CurrentOptions() > 0 and not self._votingCancelled then
				self.Network.VoteOptions:FireClient(player, self.CurrentOptions(), self.TimeLeft())
				task.defer(function() 
					if player and player.Parent then 
						self.Network.VoteUpdate:FireClient(player, self:_calculateVoteCounts()) 
					end 
				end)
			end
		end)
	end)

	task.spawn(function()
		while true do
			while #Players:GetPlayers() < CONFIG.MIN_PLAYERS do 
				if self.GameStatus() ~= "Intermission" then 
					self:ResetMatch() 
				end
				task.wait(5) 
			end

			task.wait(CONFIG.INTERMISSION)

			local success, promise = pcall(function() 
				return self:StartGame() 
			end)

			if success and promise then
				local promiseSuccess, promiseResult = pcall(function() 
					return promise:getStatus() ~= Promise.Status.Rejected 
				end)

				if promiseSuccess and promiseResult then
					if self._isGameActive then 
						self.Signals.GameEnded:Wait() 
					end
					task.wait(CONFIG.RESULT_SCREEN_TIME) 
					self:ResetMatch()
				else
					warn("Game failed:", promiseResult)
					-- [CRITICAL FIX] Önce Reset at, sonra bekle. 
					-- Bu sayede oyuncular bozuk ekranda beklemez.
					self:ResetMatch()
					task.wait(3)
				end
			else
				warn("Failed to start game:", promise)
				self:ResetMatch()
				task.wait(3)
			end
		end
	end)
end

return GameService]]></ProtectedString>
				<string name="ScriptGuid">{16AB58D6-0947-48A1-AF2C-9237A352B3C2}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">GameService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX7BF2BEB541AA42CB96909CB38FFC2771">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")

local Services = ServerStorage:WaitForChild("Services")
local Modules = ServerStorage:WaitForChild("Modules")

local DataService = require(Services:WaitForChild("DataService"))
local BetterAnalytics = require(Modules:WaitForChild("BetterAnalyticsService"))

local RewardService = {
	Name = script.Name,
	Client = {}
}

--// YARDIMCI FONKSİYON: Çarpan Hesaplayıcı
local function GetMultiplier(player)
	-- Eğer oyuncuda VIP özelliği varsa 2, yoksa 1 döner
	if player:GetAttribute("VIP") then
		return 2
	end
	return 1
end

function RewardService:AddCurrency(player, amount, reason)
	local safeAmount = tonumber(amount)
	if not safeAmount or safeAmount <= 0 then return end

	reason = reason or "GameplayReward"

	-- 1. VIP KONTROLÜ (2x TOKEN)
	-- Normal miktar ile çarpanı çarpıyoruz
	local multiplier = GetMultiplier(player)
	safeAmount = safeAmount * multiplier

	-- Konsola bilgi (Opsiyonel, debug için)
	if multiplier > 1 then
		print("[RewardService] VIP Bonus Aktif: 2x Token kazandı!")
	end

	-- 2. Veriyi DataService üzerinden güncelle
	local newBalance = DataService:UpdateValue(player, "CurrencyData.Value", safeAmount)

	-- Eğer profil yüklü değilse işlem durur
	if not newBalance then return end

	-- Toplam kazanılan parayı da güncelle (İstatistik için)
	DataService:UpdateValue(player, "CurrencyData.Total", safeAmount)

	print("[RewardService] " .. player.Name .. " +" .. safeAmount .. " Token (" .. reason .. ")")

	-- 3. ANALYTICS
	-- Analytics'e X2 uygulanmış gerçek kazanılan değeri gönderiyoruz.
	BetterAnalytics:LogEconomyEvent(
		player,
		"Source",     -- Flow: Gelir
		"Token",      -- Currency
		safeAmount,   -- Miktar (x2 dahil)
		newBalance,   -- Güncel Bakiye
		"Gameplay",   -- TransactionType
		reason,       -- ItemSku
		nil           -- CustomFields
	)
end

function RewardService:AddXP(player, amount)
	-- Veriyi okuyoruz
	local currentData = DataService:GetData(player)
	if not currentData then return end

	local levelData = currentData.LevelData

	-- 1. VIP KONTROLÜ (2x XP)
	-- Kazanılan XP miktarını çarpıyoruz
	local multiplier = GetMultiplier(player)
	local finalAmount = amount * multiplier

	-- Hesaplamaları yapalım
	local newXP = levelData.ValueXP + finalAmount
	local currentLevel = levelData.Level
	local currentTarget = levelData.TargetXP

	local leveledUp = false

	-- Level atlama döngüsü
	while newXP >= currentTarget do
		newXP = newXP - currentTarget
		currentLevel = currentLevel + 1
		currentTarget = math.floor(currentTarget * 1.2) -- Zorluk artışı
		leveledUp = true
	end

	-- 2. Sonuçları DataService'e kaydet
	DataService:SetValue(player, "LevelData.ValueXP", newXP)

	if leveledUp then
		-- Level ve Hedef XP'yi güncelle
		DataService:SetValue(player, "LevelData.Level", currentLevel)
		DataService:SetValue(player, "LevelData.TargetXP", currentTarget)

		-- Bonus ver (Level atlayınca verilen para)
		-- NOT: Buradaki 50 token de AddCurrency içindeki VIP kontrolü sayesinde 
		-- otomatik olarak 100 token olacaktır.
		self:AddCurrency(player, 50, "LevelUpBonus")
	end
end

function RewardService:OnStart()
	-- Başlangıç işlemleri gerekirse buraya
end

return RewardService]]></ProtectedString>
				<string name="ScriptGuid">{6FDD41F0-CBB7-4856-A503-B94CC061CC83}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">RewardService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX9374C5E361784BA79FFC7014A18F55BF">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local MarketplaceService = game:GetService("MarketplaceService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")

local Signal = require(Packages:WaitForChild("Signal"))
local Net = require(Packages:WaitForChild("Net"))

-- Module
local MonetizationService = {
	Name = script.Name,
	Client = {},

	-- Kayıt edilen fonksiyonları tutacağımız tablolar
	_productHandlers = {},
	_gamepassHandlers = {},

	-- Enum gibi kullanım için tipler
	Type = {
		Product = "Product",
		Gamepass = "Gamepass"
	},

	Signals = {
		PurchaseCompleted = Signal.new()
	},
	Network = {
		PurchaseCompleted = Net:RemoteEvent("PurchaseCompleted")
	}
}

-- Satın alma işlemi tanımlama fonksiyonu
function MonetizationService:Register(type, id, callback)
	if type == self.Type.Product then
		self._productHandlers[id] = callback
	elseif type == self.Type.Gamepass then
		self._gamepassHandlers[id] = callback
	end
end

-- Developer Product satın aldırma
function MonetizationService:PromptProduct(player, productId)
	MarketplaceService:PromptProductPurchase(player, productId)
end

-- Gamepass satın aldırma
function MonetizationService:PromptGamepass(player, gamePassId)
	MarketplaceService:PromptGamePassPurchase(player, gamePassId)
end

-- Oyuncunun Gamepass'e sahip olup olmadığını kontrol etme
function MonetizationService:UserHas(player, gamePassId)
	local success, hasPass = pcall(function()
		return MarketplaceService:UserOwnsGamePassAsync(player.UserId, gamePassId)
	end)

	if success then
		return hasPass
	end
	return false
end

function MonetizationService:OnInit()
	-- Developer Product İşlemleri (ProcessReceipt)
	MarketplaceService.ProcessReceipt = function(receiptInfo)
		local playerId = receiptInfo.PlayerId
		local productId = receiptInfo.ProductId
		local player = Players:GetPlayerByUserId(playerId)

		local handler = self._productHandlers[productId]

		if handler and player then
			-- Handler fonksiyonunu çalıştır (başarılıysa true dönmeli)
			local success, result = pcall(handler, player)

			if success and result == true then
				self.Signals.PurchaseCompleted:Fire(player, productId, self.Type.Product)
				return Enum.ProductPurchaseDecision.PurchaseGranted
			end
		end

		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	-- Gamepass İşlemleri
	MarketplaceService.PromptGamePassPurchaseFinished:Connect(function(player, gamePassId, wasPurchased)
		if wasPurchased then
			local handler = self._gamepassHandlers[gamePassId]

			if handler then
				task.spawn(handler, player)
			end

			self.Signals.PurchaseCompleted:Fire(player, gamePassId, self.Type.Gamepass)
		end
	end)
end

function MonetizationService:OnStart()
end

return MonetizationService]]></ProtectedString>
				<string name="ScriptGuid">{a11f3d1a-0ebc-46a4-9154-d50eee3d894f}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">MonetizationService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXFA480BED22924612A132321CBD82B119">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Trove = require(Packages:WaitForChild("Trove"))

local DoorKey = "Door"

-- Module
local DoorService = {
	Name = script.Name,
	Client = {},
	Troves = {}
}

-- Helper
local function GetSortedSteps(StepsFolder: Folder)
	local steps = StepsFolder:GetChildren()
	table.sort(steps, function(a, b)
		return (tonumber(a.Name) or 0) < (tonumber(b.Name) or 0)
	end)
	return steps
end

-- Bir adımın (Step) içindeki tüm parçaları sadece Anchorlar.
-- Görünürlük (Parenting) işlemi CreateDoor içinde yönetilecek.
local function AnchorStepParts(stepInstance: Instance)
	local parts = {}
	if stepInstance:IsA("BasePart") then
		table.insert(parts, stepInstance)
	end
	for _, desc in ipairs(stepInstance:GetDescendants()) do
		if desc:IsA("BasePart") then
			table.insert(parts, desc)
		end
	end

	for _, part in ipairs(parts) do
		part.Anchored = true -- Hepsini çiviliyoruz, düşmesinler
	end
end

local function CreateDoor(Door: Model)
	local Activator = Door:FindFirstChild("_Activator") :: BasePart
	local StepsFolder = Door:FindFirstChild("Steps") :: Folder

	if not (Activator and StepsFolder) then return end

	local sortedSteps = GetSortedSteps(StepsFolder)
	if #sortedSteps < 2 then 
		warn(Door.Name .. " yeterli step yok!") 
		return 
	end

	-- Activator Ayarları
	Activator.Transparency = 1
	Activator.CanCollide = false -- İçinden geçilebilir
	Activator.CanQuery = false -- Raycast görmezden gelir
	Activator.CanTouch = true -- Dokunma algılaması için TRUE olmalı
	Activator.Anchored = true

	local NewTrove = Trove.new()

	-- Attributes
	local CompletionTime = Door:GetAttribute("CompletionTime") or 1
	local Lifetime = Door:GetAttribute("Lifetime") or 2

	NewTrove:Connect(Door:GetAttributeChangedSignal("CompletionTime"), function()
		CompletionTime = Door:GetAttribute("CompletionTime")
	end)
	NewTrove:Connect(Door:GetAttributeChangedSignal("Lifetime"), function()
		Lifetime = Door:GetAttribute("Lifetime")
	end)

	-- Başlangıç Durumu: 
	-- 1. Tüm parçaları Anchorla.
	-- 2. Sadece ilk adım (1. Step) klasörde kalsın, diğerlerinin Parent'i nil olsun.
	for i, step in ipairs(sortedSteps) do
		AnchorStepParts(step) -- Parçaları sabitle

		if i == 1 then
			step.Parent = StepsFolder -- İlk kare görünür
		else
			step.Parent = nil -- Diğerleri yok
		end
	end

	local isBusy = false
	local isOpen = false

	local function Operate()
		if isBusy or isOpen then return end
		isBusy = true

		local stepCount = #sortedSteps
		-- Geçiş süresi hesaplama (Adım sayısı - 1 kadar geçiş vardır)
		local delayPerStep = CompletionTime / (stepCount - 1)

		-- AÇILMA (Forward: 1 -> N)
		for i = 1, stepCount - 1 do
			task.wait(delayPerStep)

			-- Şu anki adımı bellekten silmeden sahneden kaldır (Parent = nil)
			sortedSteps[i].Parent = nil
			-- Bir sonraki adımı sahneye koy (Parent = Folder)
			sortedSteps[i+1].Parent = StepsFolder
		end

		isOpen = true
		task.wait(Lifetime)

		-- KAPANMA (Backward: N -> 1)
		for i = stepCount, 2, -1 do
			task.wait(delayPerStep)

			-- Şu anki adımı kaldır
			sortedSteps[i].Parent = nil
			-- Bir önceki adımı geri getir
			sortedSteps[i-1].Parent = StepsFolder
		end

		isOpen = false
		isBusy = false
	end

	NewTrove:Connect(Activator.Touched, function(hit)
		if isBusy then return end
		if hit.Parent:FindFirstChild("Humanoid") then
			Operate()
		end
	end)

	NewTrove:AttachToInstance(Door)
	DoorService.Troves[Door] = NewTrove
end

local function RemoveDoor(Door: Model)
	if DoorService.Troves[Door] then
		DoorService.Troves[Door]:Destroy()
		DoorService.Troves[Door] = nil
	end
end

-- Server

function DoorService:CreateDoor(Door: Model)
	return CreateDoor(Door)
end

function DoorService:RemoveDoor(Door: Model)
	return RemoveDoor(Door)
end

function DoorService:OnStart()
	CollectionService:GetInstanceAddedSignal(DoorKey):Connect(CreateDoor)
	CollectionService:GetInstanceRemovedSignal(DoorKey):Connect(RemoveDoor)
	for _,Door in ipairs(CollectionService:GetTagged(DoorKey)) do
		CreateDoor(Door)
	end
end

return DoorService]]></ProtectedString>
				<string name="ScriptGuid">{A684DBB7-DCAA-4940-AE52-EA76EAC37258}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">DoorService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX427C7AD366BB4181A4DFD436BB59F416">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")

local Zone = require(Packages:WaitForChild("Zone"))
local Net = require(Packages:WaitForChild("Net"))

local ZoneContainer = workspace:WaitForChild("Zone")

-- Module
local ZoneService = {
	Name = script.Name,
	Client = {}
}

function ZoneService:CreateZone(Container, PlayerEntered : (Player) -> (), PlayerExited : (Player) -> ())
	local NewZone = Zone.new(Container)
	NewZone.PlayerEntered:Connect(PlayerEntered)
	NewZone.PlayerExited:Connect(PlayerExited)
	
	return NewZone
end

function ZoneService:OnStart()
	local PopupEvent = Net:RemoteEvent("Popup")
	
	-- VIP
	self:CreateZone(ZoneContainer:WaitForChild("VIP"), function(Player : Player)
		PopupEvent:FireClient(Player, "Show", "VIPPopup")
	end, function(Player : Player)
		PopupEvent:FireClient(Player, "Hide", "VIPPopup")
	end)
	
	-- Group Reward
	self:CreateZone(ZoneContainer:WaitForChild("GroupReward"), function(Player : Player)
		PopupEvent:FireClient(Player, "Show", "GroupPopup")
	end, function(Player : Player)
		PopupEvent:FireClient(Player, "Hide", "GroupPopup")
	end)
end

return ZoneService]]></ProtectedString>
				<string name="ScriptGuid">{8194E1FA-EFA1-44B2-8A4B-EE21C93C7901}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ZoneService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX0911C9CA80CB465493AA8222B476965C">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

-- Variables
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Services = ServerStorage:WaitForChild("Services")

local FormatKit = require(Packages:WaitForChild("FormatKit"))
local DataService = require(Services:WaitForChild("DataService"))

-- Constants
local GROUP_ID = 683942179
local REQUIRED_TIME = 300 -- 5 Dakika (Saniye cinsinden)

-- Module
local GroupRewardService = {
	Name = script.Name,
	Client = {},
	Players = {} -- Oyuncuların giriş zamanını (os.clock) tutar
}

function GroupRewardService.Client:Verify(player : Player)
	return GroupRewardService:Verify(player)
end

function GroupRewardService:Verify(player)
	local Data = DataService:GetData(player)
	if (Data and Data.GroupRewardCompleted) then
		return false, "You already completed."
	end

	-- 1. Verileri Al
	local joinTime = self.Players[player]

	-- Eğer veri yoksa hata ver (Oyuncu yüklenmemiş olabilir)
	if not joinTime then 
		return false, "An error occurred while checking your data. Please rejoin." 
	end

	-- 2. Kontrolleri Yap
	local isInGroup = player:IsInGroupAsync(GROUP_ID)
	local timePlayed = os.clock() - joinTime
	local hasEnoughTime = timePlayed >= REQUIRED_TIME

	-- 3. Mantık Akışı (Logic Flow)

	-- DURUM A: Grupta Değil (Süreye bakmaksızın öncelik grup)
	if not isInGroup then
		return false, "You must complete steps to claim this reward."
	end

	-- DURUM B: Grupta AMA Süresi Dolmamış
	if isInGroup and not hasEnoughTime then
		local remainingSeconds = REQUIRED_TIME - timePlayed

		-- Kullanıcıya kalan süreyi gösteriyoruz
		return false, `You need to play for {FormatKit.FormatTime(remainingSeconds, "m:ss")} more minutes.`
	end

	-- DURUM C: Her ikisi de Tamam (Success)
	if isInGroup and hasEnoughTime then
		DataService:GetProfile(player):andThen(function(Profile)
			Profile.Data.GroupRewardCompleted = true
			Profile.Data.KillerSkins["Grass"] = true
		end)
		return true, "Success! You have completed all the requirements."
	end

	return false, "Unknown error."
end

function GroupRewardService:OnStart()
	local function PlayerAdded(player : Player)
		-- Oyuncu girdiğinde şu anki zamanı kaydet
		self.Players[player] = os.clock()
	end

	for _, player in ipairs(Players:GetPlayers()) do
		PlayerAdded(player)
	end

	Players.PlayerAdded:Connect(PlayerAdded)

	Players.PlayerRemoving:Connect(function(player : Player)
		self.Players[player] = nil
	end)
end

return GroupRewardService]]></ProtectedString>
				<string name="ScriptGuid">{F120F3D0-5FA1-411E-A565-77D455C177FF}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">GroupRewardService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>